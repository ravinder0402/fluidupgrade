NAME: ccs
LAST DEPLOYED: Tue Mar 25 05:36:08 2025
NAMESPACE: ccs
STATUS: pending-install
REVISION: 1
HOOKS:
---
# Source: ccs/charts/grafana/templates/tests/test-serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  labels:
    helm.sh/chart: grafana-6.52.1
    app.kubernetes.io/name: grafana
    app.kubernetes.io/instance: ccs
    app.kubernetes.io/version: "9.4.3"
    app.kubernetes.io/managed-by: Helm
  name: ccs-grafana-test
  namespace: ccs
  annotations:
    "helm.sh/hook": test-success
    "helm.sh/hook-delete-policy": "before-hook-creation,hook-succeeded"
---
# Source: ccs/charts/grafana/templates/tests/test-configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: ccs-grafana-test
  namespace: ccs
  annotations:
    "helm.sh/hook": test-success
    "helm.sh/hook-delete-policy": "before-hook-creation,hook-succeeded"
  labels:
    helm.sh/chart: grafana-6.52.1
    app.kubernetes.io/name: grafana
    app.kubernetes.io/instance: ccs
    app.kubernetes.io/version: "9.4.3"
    app.kubernetes.io/managed-by: Helm
data:
  run.sh: |-
    @test "Test Health" {
      url="http://ccs-grafana/api/health"

      code=$(wget --server-response --spider --timeout 90 --tries 10 ${url} 2>&1 | awk '/^  HTTP/{print $2}')
      [ "$code" == "200" ]
    }
---
# Source: ccs/charts/grafana/templates/tests/test.yaml
apiVersion: v1
kind: Pod
metadata:
  name: ccs-grafana-test
  labels:
    helm.sh/chart: grafana-6.52.1
    app.kubernetes.io/name: grafana
    app.kubernetes.io/instance: ccs
    app.kubernetes.io/version: "9.4.3"
    app.kubernetes.io/managed-by: Helm
  annotations:
    "helm.sh/hook": test-success
    "helm.sh/hook-delete-policy": "before-hook-creation,hook-succeeded"
  namespace: ccs
spec:
  serviceAccountName: ccs-grafana-test
  containers:
    - name: ccs-test
      image: "bats/bats:v1.4.1"
      imagePullPolicy: "IfNotPresent"
      command: ["/opt/bats/bin/bats", "-t", "/tests/run.sh"]
      volumeMounts:
        - mountPath: /tests
          name: tests
          readOnly: true
  volumes:
    - name: tests
      configMap:
        name: ccs-grafana-test
  restartPolicy: Never
---
# Source: ccs/charts/keycloak-ha/templates/pg-cluster-job.yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: "pg-cluster-ready"
  namespace:  ccs
  annotations:
    "helm.sh/hook": post-install,pre-upgrade
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
spec:
  spec:
  backoffLimit: 5
  activeDeadlineSeconds: 600
  template:
    spec:
      restartPolicy: Never
      serviceAccountName: keycloak-postgresql-operator
      containers:
      - name: pg-cluster-readiness
        image: coredgeio/kubectl:1.18.16
        imagePullPolicy: IfNotPresent
        command:
        - /bin/bash
        - -c
        - |
          i=0
          while [ $i -ne 120 ]; do
            i=$(($i+1))
            sleep 5
            kubectl get postgresql -n ccs keycloak-postgresql-cluster -o=jsonpath='{.status.PostgresClusterStatus}' | grep Running
            if [ $? == "0" ]; then
              exit 0
            fi
            echo "Waiting for postgresql cluster to be ready!"
          done
---
# Source: ccs/charts/keycloak-ha/templates/pg-cluster-job.yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: "pg-cluster-cleanup"
  namespace:  ccs
  annotations:
    "helm.sh/hook": pre-delete
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
spec:
  spec:
  backoffLimit: 5
  activeDeadlineSeconds: 600
  template:
    spec:
      restartPolicy: Never
      serviceAccountName: keycloak-postgresql-operator
      containers:
      - name: pg-cluster-cleanup
        image: coredgeio/kubectl:1.18.16
        imagePullPolicy: IfNotPresent
        command:
        - /bin/bash
        - -c
        - |
          i=0
          while [ $i -ne 40 ]; do
            i=$(($i+1))
            kubectl delete postgresql -n ccs keycloak-postgresql-cluster --ignore-not-found=true
            output=$(kubectl get pod -n ccs --selector=cluster-name=keycloak-postgresql-cluster --field-selector status.phase=Running | wc -l)            
            if [ "$output" == "0" ]; then
              echo "Postgresql cluster cleanup success!"
              kubectl delete svc -l cluster-name=keycloak-postgresql-cluster -n ccs
              kubectl delete svc --all -n ccs
              exit 0
            fi
            echo "Waiting for postgresql cluster cleanup!"
            sleep 5
          done
---
# Source: ccs/templates/postgresql-ha/job.yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: ccs-pg-cluster-ready
  namespace:  ccs
  annotations:
    "helm.sh/hook": post-install,pre-upgrade
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
spec:
  spec:
  backoffLimit: 5
  activeDeadlineSeconds: 600
  template:
    spec:
      restartPolicy: Never
      serviceAccountName: ccp-postgresql-operator
      containers:
      - name: pg-cluster-readiness
        image: coredgeio/kubectl:1.18.16
        imagePullPolicy: IfNotPresent
        command:
        - /bin/bash
        - -c
        - |
          i=0
          while [ $i -ne 120 ]; do
            i=$(($i+1))
            sleep 5
            kubectl get postgresql -n ccs ccs-postgresql-cluster -o=jsonpath='{.status.PostgresClusterStatus}' | grep Running
            if [ $? == "0" ]; then
              exit 0
            fi
            echo "Waiting for postgresql cluster to be ready!"
          done
MANIFEST:
---
# Source: ccs/charts/postgres-operator/templates/postgres-pod-priority-class.yaml
apiVersion: scheduling.k8s.io/v1
description: 'Use only for databases controlled by Postgres operator'
kind: PriorityClass
metadata:
  labels:
    app.kubernetes.io/name: postgres-operator
    helm.sh/chart: postgres-operator-1.12.2
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/instance: ccs
  name: ccs-postgres-operator-pod
  namespace: ccs
preemptionPolicy: PreemptLowerPriority
globalDefault: false
value: 1e+06
---
# Source: ccs/charts/grafana/templates/serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  labels:
    helm.sh/chart: grafana-6.52.1
    app.kubernetes.io/name: grafana
    app.kubernetes.io/instance: ccs
    app.kubernetes.io/version: "9.4.3"
    app.kubernetes.io/managed-by: Helm
  name: ccs-grafana
  namespace: ccs
---
# Source: ccs/charts/keycloak-ha/templates/postgresql-rbac.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: keycloak-postgresql-operator
  namespace: ccs
---
# Source: ccs/charts/keycloak-ha/templates/serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: keycloak
  namespace: ccs
---
# Source: ccs/charts/postgres-operator/templates/serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: postgresql-operator
  namespace: ccs
  labels:
    app.kubernetes.io/name: postgres-operator
    helm.sh/chart: postgres-operator-1.12.2
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/instance: ccs
---
# Source: ccs/templates/postgresql-ha/rbac.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: ccp-postgresql-operator
  namespace: ccs
---
# Source: ccs/templates/rbac.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: compass-controller
  namespace: ccs
---
# Source: ccs/charts/auth-service/templates/secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: keycloak-secret
  namespace: ccs
stringData:
  keycloak.yml: |
    url: "https://keycloak:8443"
    
    clients:
    - controller
    
    realm: "cloud"
    dns: ""
    providerUrl: http://127.0.0.1:32500
    admin:
      username: "ccsadmin"
      password: "Welcome@123"
      firstname: "CCS"
      lastname: "Admin"
      email: "info@coredge.io"
    
    
    redirectURIs:
    - '*'
    
    
    webOrigins:
    - '*'
---
# Source: ccs/charts/grafana/templates/secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: ccs-grafana
  namespace: ccs
  labels:
    helm.sh/chart: grafana-6.52.1
    app.kubernetes.io/name: grafana
    app.kubernetes.io/instance: ccs
    app.kubernetes.io/version: "9.4.3"
    app.kubernetes.io/managed-by: Helm
type: Opaque
data:
  admin-user: "YWRtaW4="
  admin-password: "YWRtaW5AY29tcGFzcw=="
  ldap-toml: ""
---
# Source: ccs/charts/keycloak-ha/templates/secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: keycloak-creds
  namespace: ccs
type: Opaque
stringData:
  username: admin
  password: admin
---
# Source: ccs/charts/keycloak-ha/templates/secret.yaml
---
apiVersion: v1
kind: Secret
metadata:
  name: keycloak-tls
  namespace: ccs
type: Opaque
data:
  tls.crt: |
    LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUR3ekNDQXF1Z0F3SUJBZ0lVWk1BM2RpS1RzbUFXZFZpZHJWVld6N0UzbGxFd0RRWUpLb1pJaHZjTkFRRUwKQlFBd2NURUxNQWtHQTFVRUJoTUNWVk14RGpBTUJnTlZCQWdNQlZOMFlYUmxNUTB3Q3dZRFZRUUhEQVJEYVhSNQpNUlV3RXdZRFZRUUtEQXhQY21kaGJtbDZZWFJwYjI0eEV6QVJCZ05WQkFzTUNrUmxjR0Z5ZEcxbGJuUXhGekFWCkJnTlZCQU1NRG5sdmRYSmtiMjFoYVc0dVkyOXRNQjRYRFRJME1EY3dPVEU0TXpRMU5Gb1hEVEkxTURjd09URTQKTXpRMU5Gb3djVEVMTUFrR0ExVUVCaE1DVlZNeERqQU1CZ05WQkFnTUJWTjBZWFJsTVEwd0N3WURWUVFIREFSRAphWFI1TVJVd0V3WURWUVFLREF4UGNtZGhibWw2WVhScGIyNHhFekFSQmdOVkJBc01Da1JsY0dGeWRHMWxiblF4CkZ6QVZCZ05WQkFNTURubHZkWEprYjIxaGFXNHVZMjl0TUlJQklqQU5CZ2txaGtpRzl3MEJBUUVGQUFPQ0FROEEKTUlJQkNnS0NBUUVBcFd1c3RHY3hVaTNWYkxKenZIVldQTkZBQTJyd0FrMFMraVltOE03K20zaWU1ckVPNERCaApiRjlEYkpaZW9KZDNMTEZLdWx5VVNidmlyOFQxTERXSVdqMUtYSXp0aVpFMXpTVDAvZUhCTG1tWFFubHB3aFFDCk5RQXlDYmd1elRCekQ2dEZrWG9EdGVYR0VMbGQxQzJDeFU2YVVXbWZ5T3lYU05yclp1QWJJbWh0TzZDUWJoeDgKd2xZMWlBTGQ1MExSTUludDA4elI1UkdsSDdVNVdnd1ZKUEgzYjZPNHFxZ2VDdStWVlo5NXIvRDZKRVVmNTBCaQpiOXhNTlFWbDdKYXVFN0JYMStqd2pvbExZNVl0R1ZPV0tWZWg2a05Tc3A4ZFhXMWxWZ2tBZERvL1hXYStYYjhZCkFGcEdNbVNnN2FEYTdkZTRUUi80SHN3bS9XeHV1THBVK1FJREFRQUJvMU13VVRBZEJnTlZIUTRFRmdRVTZUQkoKUWUwaGFZMkxUOXljRktnN2tzdVpKbmN3SHdZRFZSMGpCQmd3Rm9BVTZUQkpRZTBoYVkyTFQ5eWNGS2c3a3N1WgpKbmN3RHdZRFZSMFRBUUgvQkFVd0F3RUIvekFOQmdrcWhraUc5dzBCQVFzRkFBT0NBUUVBZGl6UWFELzlVNzlOCklIek1ZMDJUeUNXVlVQeHY5eUZBTnpYTHFCQkMrdkxNSm10R09vTDlMdmZ3UWptc2FmVUtFS1MvcEFJVGUzM1EKakVwbVZCVTJ1M1g2WkxKcXpqc2NOUzlzMWV6d3F6L1QxUHBQUW1jajh0VUhSQ0RhWmJlU0pjQUovY2ZGMndpMApxdVMvZFFTdzBEUktDdzF0QXlEbkxudE52bXRqNFg2MWlPa2dsckhPSUFhQlE5VVl6SjhnWlp0Z1owRlZnc2pZCld0bUo3aGxhYi9oSjlxdVhyUGFnRWp0UTJNbzdlUENEeFgraVJ5Q2JlQ1pIYWdRdjBjNXl2SVVLWVNWYVdOanEKQVZOQ0x1UTFEV25pUlE2cFhNVlFsM3RPZ3JKaWxGdHRFd2txYUg4MzZmYVlWQk5aditvQk05bmNvQ3MxZXRRNwp4Tjk1Y2xOVDZBPT0KLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLQ==
  tls.key: |
    LS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tCk1JSUV2UUlCQURBTkJna3Foa2lHOXcwQkFRRUZBQVNDQktjd2dnU2pBZ0VBQW9JQkFRQ2xhNnkwWnpGU0xkVnMKc25POGRWWTgwVUFEYXZBQ1RSTDZKaWJ3enY2YmVKN21zUTdnTUdGc1gwTnNsbDZnbDNjc3NVcTZYSlJKdStLdgp4UFVzTlloYVBVcGNqTzJKa1RYTkpQVDk0Y0V1YVpkQ2VXbkNGQUkxQURJSnVDN05NSE1QcTBXUmVnTzE1Y1lRCnVWM1VMWUxGVHBwUmFaL0k3SmRJMnV0bTRCc2lhRzA3b0pCdUhIekNWaldJQXQzblF0RXdpZTNUek5IbEVhVWYKdFRsYURCVWs4ZmR2bzdpcXFCNEs3NVZWbjNtdjhQb2tSUi9uUUdKdjNFdzFCV1hzbHE0VHNGZlg2UENPaVV0agpsaTBaVTVZcFY2SHFRMUt5bngxZGJXVldDUUIwT2o5ZFpyNWR2eGdBV2tZeVpLRHRvTnJ0MTdoTkgvZ2V6Q2I5CmJHNjR1bFQ1QWdNQkFBRUNnZ0VBRDlvUzVZSExDZWsrL2NqWEN1MENtOWJnaDhOUVp5UU1LTUVOczc5ZVNqZEQKb085QU1lOG84dG5wSytkMy8zTXNWakhTSzZ3eUFLUGEzQVduaWZwQ1RBVjZFZ2JtUDJ2VktFaTltbk92RDd2SwpKVEpkMWwyVS9ZKzhlODUwMjdCa0lsRURIR2NCSW9YM2xrUXhMK05CbUJkSmRmcEZkOXRtUHZMTm9xRGdzTW9DCkVTZzA0b2IwOFgvNmU3ejAwclpUcDBpeFh6TmZtcjRQMTg1S1dyT3B4RHNQM0NqdEpSZmJuQllYSS8weG84RkgKWkovcnUzYzUwV0Iyc2N6U2ZZSzZUQk5QdzMwaktmSnRtUXBJV0JURnpTMm5tSlcxQVpSMzg4ZWRzOW9FS2dNcApVN2VoeUZTZjdDNE1keFJ5RXlTbUhVOGcyb2NydGw5N29Ra3JTclg3MVFLQmdRRFU0bzZaQTRYWXl5MFFsY3RRCkJJcVVrY3p1dFMxVGhpZmIzelE0THovRnJQa2x1VjJqSlJDMndIOTN6SnpieXc1Y0xJZ1c1Snk0MHdCaXU4WU8Kb2syYy83SFc5UkRBNEU4L3hhQnFTdExqcGh5aEFnNHRyUHBuTnF1akM5ekpCUWgrWk9nbTNhZm1UemF4VXkwRAp2MEJDOGszdTc2Mk41YTROYko4RUV6Qzk3UUtCZ1FERzdEdVgremlTVVNYSU5sMVJnbG03NHcxNTVyZVhvNCtnCk1GM2NUczBRMmV2cUFmcVVRSmNaaEk2eTAwdjhBYzlIZ1BhbUgrWUFvdzI5MDQ1NFRmbktoQVFOd28zajFvN0UKMHQxYjZDQ2xFQnV5WU0xSnAvRHZ2UzI5ZGU3SlYrS2IvbUJPRzg3VWVjRDdGdUhpT3NVdmY5QkNPRmQ0bnVvYgpZUG5BeUhyeHZRS0JnRVRoYlV3N0pKS3A0dEhyOWRYVk1sV3grMEg5WTBZVU1VOW1JQXBSMTJ1SmRTL3NrMHlYClVKb2hITjFSV2l1UHZ2eTU5K3FZVzlFOWpIRmwya2FmNDBiNlFMdVJuYk1hb09tOGN4UVJVNzBPNFZLRFRMMGcKckFDN1lydWx1ZkZjN0l1ZzhMQ3FwWW5TZFpyWWs4Y1RtYUpQcmtHeVVWQ0pVVkRNcFlMM0JwMWRBb0dBUCtudApKK0xuQlZRZllKbmZGKzVhNkp5R1d2Ri9jYkJ5MkZSU0JCUXBuVTEzbUdOMFlLZjBKSlhMeDdkT1JiVkxKVDFSCmdvVGpRTGNqRmlmZ01kVlQrZmE2MnJUMUpBeHZLTnhibFVrYkhBMzE2RFZrSUZOZWZaajZGbExMRzFRcWtsYUUKR1BTa1d1Nlh5OVZKVklmdmpWaHkwS1FMcnN6WWlWMTZRYS9vbUwwQ2dZRUFoYTNEMktjbk9UcWQ0aW8xRGovTApDcjJuNG1sQUlNL0hCK2k2MmZEVGFEKzYwTGtyYXRtTG1kRXBkWWJWRXdQUnhUVHNSSXhGNGdqMFZ5NWRZS0ZmCkhpWW1oeG5NQUZoVjIzQWYyZ0NuNU5xQVNkaXd3ZWlrUStlb0haUzEvb2FaeS9GdEVxZ1VadWs3MEFyTHdMR1EKb0pHZWZveHFudWk4ZHdKQ0RQRUhIMUk9Ci0tLS0tRU5EIFBSSVZBVEUgS0VZLS0tLS0=
---
# Source: ccs/charts/repository-cred/templates/secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: ccs-docker-registry-key
  namespace: ccs
data:
  .dockercfg: eyJkb2NrZXIuaW8iOiB7InVzZXJuYW1lIjoiZG9ja2VyIiwicGFzc3dvcmQiOiJkb2NrZXIiLCJlbWFpbCI6ImluZm9AY29yZWRnZS5pbyIsImF1dGgiOiJaRzlqYTJWeU9tUnZZMnRsY2c9PSJ9fQ==
type: kubernetes.io/dockercfg
---
# Source: ccs/templates/postgresql-ha/secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: ccs.ccs-postgresql-cluster.credentials.postgresql.acid.zalan.do
  namespace: ccs
type: Opaque
data:
  password: "Y2NzZGJhZG1pbg=="
  username: "Y2Nz"
---
# Source: ccs/templates/secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: jwt-secret
  namespace: ccs
type: Opaque
stringData:
  secretKey: 'CoredgeCloudSuite_JWT_Token_Secret'
---
# Source: ccs/templates/secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: configdb-secret
  namespace: ccs
type: Opaque
data:
  username: c2lnbWE= # sigma
  password: cGFzc3dvcmQ= # password
---
# Source: ccs/templates/secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: config-replica-auth
  namespace: ccs
type: Opaque
data:
  auth: Mm1wQXZjYTFpRWZ5UjFRTjZQNEJkUmhEMGY2TGV6c0JzK295S2RoK2lHQWIwT2l0dTJFRitvSEUyZkNCTVlTMQpaRENOakNUa2dQMGNqTlpoei9ha3lnN1ZCMVNDVEpnb29tV2dOeSsrWThEOFE2T3VsUmd1UlU2b20yNjJJSnlWClVMSTFocHJ1Qi9nWXhPamVKZ2NDOHVoS3NlVmtmTmhCVjZsaWF2RFAzUEdqMEtRWFBOY01WQUFFVkFWbS9QeUYKY3dZLzRDdXBtQmdkcE9UeXk3WXJSMU03QUxLOUFFS016dWpPRk44YkZvU3hENTd2dXlkK2pLZ29QOWxTM2x6dwpYUUVnN244Tmg4MGN2VFlXVklxbStBTStrTkRiT0hCSjZ5OXRDL21PVGNqUmFOMWZzeXdOYW5FelBmQ3NpcUdqCnZhOFNoSmVBOS9lU3BIeUNjS0s3SUZGVE5yMlJFdnhNNnNwQWptMTFWU1VOb0NpT055cTBDMEZ2dGZDS3lFZzAKQ1c2bkhOSjJ5enFPVk1uRExESyt4RVNuWm1FWVk3ejdrVDR4RVVOL2d4bmxMUVJNTmw4blRPaWhDZlR4dEhqcgpYZHcyR1VwZGxTTXpmWndvVU9aYSt2b1dEa2lvZVQralQyRnd2amR4N1l4cGlvWHBYQzlXRStBUmxDcEZPR01lClFPNUpIK2hlb1lSTDdYVW9BV0txa1ZDTVlTMUJVeVMxZmJ2bVJpZ3Q0dHpJQzFjZUNlZ0NCemlvK29KclIxaEkKTU1WWlV5d1pNaFhNRDdkNEdGRTdKd0NlRDczVE8xMUROK29ZSjh3ZThwenhKSTFmeDlDQ09jcnhIZTVNZWZ4dApyMmY5OUtvSUgrYkhMNUpBQW01VXBObUdTZlc3YlA5NFA0dHZwU0QzRWNrTytjbEkrVlNzeS9zcUUyYlVaL1FsCkUyZjdZelpRcDRreFdUeUF4RGtLYi9QSllNdzBsV3EydklUZThKckhGc1FPMFduaW45amJpb1BZU2F2c2FXQXEKK0hGYi92Unp4U2c1NlB1NVU2c3JBa0xZUmtzb0NTTzlXTmVmSHhNWkdOYWE4YXBHbi81Uy9MY3J1bGZVVHJtcgpkaW0wOHB5U1ZOQStzL0ExMGdEQitoN0I0aXl2Z2J4dHAyUmxzSjg0VmN6UHZkMys2UWkwUVVqVSttVHVyS09CCkQ3d0dQU2R6eUkyV05VTHk1TlNtOVRSUWVRenp4Y0Fuc0licGNmVWlkOWVIcDdsMzZqRFh0TkdpcmdjV1N6S0wKRjlrb1hlUDgyUlh2M0VycUhyMXl0bTBWdmZhditOUVVhS0pDSkNySXU3c1Fza1F0Cg==
---
# Source: ccs/templates/secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: controller-certs
  namespace: ccs
data:
  rootCA.pem: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUYvVENDQStXZ0F3SUJBZ0lVTmQ3N1BQUlhtejhkaU5hdTUxM1dMRnVsYXRjd0RRWUpLb1pJaHZjTkFRRUwKQlFBd2dZMHhDekFKQmdOVkJBWVRBa2xPTVJJd0VBWURWUVFJREFsTFlYSnVZWFJoYTJFeEVqQVFCZ05WQkFjTQpDVUpoYm1kaGJHOXlaVEVUTUJFR0ExVUVDZ3dLUTI5eVpXUm5aUzVwYnpFUU1BNEdBMVVFQ3d3SFEyOXRjR0Z6CmN6RVBNQTBHQTFVRUF3d0dVbTl2ZEVOQk1SNHdIQVlKS29aSWh2Y05BUWtCRmc5cGJtWnZRR052Y21Wa1oyVXUKYVc4d0hoY05Nakl3TVRJM01EVXhNekU1V2hjTk16SXdNVEkxTURVeE16RTVXakNCalRFTE1Ba0dBMVVFQmhNQwpTVTR4RWpBUUJnTlZCQWdNQ1V0aGNtNWhkR0ZyWVRFU01CQUdBMVVFQnd3SlFtRnVaMkZzYjNKbE1STXdFUVlEClZRUUtEQXBEYjNKbFpHZGxMbWx2TVJBd0RnWURWUVFMREFkRGIyMXdZWE56TVE4d0RRWURWUVFEREFaU2IyOTAKUTBFeEhqQWNCZ2txaGtpRzl3MEJDUUVXRDJsdVptOUFZMjl5WldSblpTNXBiekNDQWlJd0RRWUpLb1pJaHZjTgpBUUVCQlFBRGdnSVBBRENDQWdvQ2dnSUJBTHhRVlhZSWVhTWhPT2pXNXY3MWc5VnVSeWpmcXBJK2VhUmcyTWR0CmMzclBPUFV0SHhETkZWdlBoUWU5N2x6NGEyeStkTWEvTXpKd0lqT05VVVlPSjdMMC9STkxVM3lkeHpSb0NnMmkKdUk2VnBNZERRUEFodnQ2U21xS1dva1lPaEJCckI0M1FUUFZHdERjUzIvRllYaTNsU2FVa0FQWTdXV0FiSmVHWApBQkZkS1cxWmtoZHE4RUl0bm5HZXNBSEZuVFVoQnJCUjJwdVlJOUNES3JtVUFZRzEzdFM0WmFIZjJobXhBcmVjCjhkRmRrczlMbmtpWEtCSjdsNGo4QnB4d2Q3bzhic01vRVZ4ZGZpZjZBOG1hMmhIMzNrK1hPK3d5U29idERVRG4KUU1IZGxoVVRXRGVZVFhrMzR6UENzT1RBN3g2NS9FZlVvdWNUR1c1QVJycEZ6TUhLUkNlQzU3c0FSS2hTdVI3Tgp3SEpsRldPRXRlU3R5VkdZOFR1NHBqYkkzdXJiVWN1UTYvMnRHVUU5WGhucGZOUkZMellaQ0xrV0t4KzdOSGlSCnhjelAyd0daYmNQdkxFSkJvUFNycFBjSG5JQ3l0dVA1K2E2bnNFTkpFWkFUUzdBQUZ4Wmp5c3RNZGVQTjNPdmwKWVA0eVp6TFYycHlaT1dMYXlWQ2F1RTVnWmlmTENPdXlLditIWCt1aHNscTRBaXV2NXROM1Y2ZTRJZzA1ZFRVTAp6eEJlUjM4aEJJMjlmOHc1aDdDNHY5TXRxMGhiSStMdyszbGVkUFlzSkpRbU50U0hTOEp0SlU2aWdOeUl0NzBzCllxOHY4YWR1ejFrV0dEK2s4TU5QZy9kWldXd3FLelV5dmcrNk42NkdQemZtMUJHMjdPN3FTMEVuaTZrNW9tUk4KOTBYekFnTUJBQUdqVXpCUk1CMEdBMVVkRGdRV0JCVFByZ0ljd2VqRnZxK1RnTWQzMW1FZ0ZLb2xpakFmQmdOVgpIU01FR0RBV2dCVFByZ0ljd2VqRnZxK1RnTWQzMW1FZ0ZLb2xpakFQQmdOVkhSTUJBZjhFQlRBREFRSC9NQTBHCkNTcUdTSWIzRFFFQkN3VUFBNElDQVFBa01sYXBod0Y5c3krdHpPVXpxKzAvSXlDOENubE9ZM2h6cXg2RXkrckYKRWsyMjBCUGgvWlFsK1FCM3BENzFubjh3SlJGbEVTa0N2UUY0NC9SUEdJbUlwWEREQ2NMa29rS01aTW5EaHkvbgpLdGdWZ1JCNTNUcWtrOHNTQVhaSzY5UEVNd05KdkZkV1RoYzhTbzh4L1owZDlnS2xTT2RQTC9SS2k2NkIrOE9CCmdNRWJ3ekxhVjhXR3ZYWHZpZXBDRGxnU005NjFGNlg5T3hCTG85V0dFQkVoVjd1aXIwV3VhVEt6QitVTmxsUTAKRE53V2F2VUFTN2E2Z1RrSVp0dGF3TnpZWXl1UkNwM1ZJSEVBRnNzM2xYVlFwUm5tdkg4My96TTlNbVRSb1NKQQppVE93Nno4cU1nZUMzSmdzWml6bWdSY1Zxa2QrVTRkS25ULzcyR25rK29BUUhEQmttbEx2enJSd2RBREd1YVVTCjF3ckR5WDlySVBoZVVpY3BRQVJSSWVsMkt6Q1dIUnlmdE16VktTS0w0Z2p4aHhtT1E5MkVmZWhUOGlkUnlVMWoKaFRVOFlmMzJuUXkxRXdEMEdwdzhYVW84a1RZL3F2U1pXR28reGVpWmZuTHRXWDBEb2dhUHFpNzFvMU1UazZxRgpKMXo0UzF4cVc3TDNCeEtVaE91a2dvck1EYmIzKzYxaDJlNGk1YUsvUmZ4UWRPYzM1ek1weFhYSTRIWnhvT1MrClVwSnZaT3VCUEZRQW9iald5a0F3M2lVaTl3V2Y3Qm9GbXBTbGRsa0E3WEFIS09hdEZ0d2JOV2twazJCL3JFTWoKMW50YWFvdEVGbjAzRVNRZ0NvTEdwS2tnYkJzWjRjdWJXdklDUDJ6MVZyWUFpNGwvenZacDhUYXh1N3lUMExONApkZz09Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K
  rootCA.key: LS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tCk1JSUpSQUlCQURBTkJna3Foa2lHOXcwQkFRRUZBQVNDQ1M0d2dna3FBZ0VBQW9JQ0FRQzhVRlYyQ0htaklUam8KMXViKzlZUFZia2NvMzZxU1BubWtZTmpIYlhONnp6ajFMUjhRelJWYno0VUh2ZTVjK0d0c3ZuVEd2ek15Y0NJegpqVkZHRGlleTlQMFRTMU44bmNjMGFBb05vcmlPbGFUSFEwRHdJYjdla3BxaWxxSkdEb1FRYXdlTjBFejFSclEzCkV0dnhXRjR0NVVtbEpBRDJPMWxnR3lYaGx3QVJYU2x0V1pJWGF2QkNMWjV4bnJBQnhaMDFJUWF3VWRxYm1DUFEKZ3lxNWxBR0J0ZDdVdUdXaDM5b1pzUUszblBIUlhaTFBTNTVJbHlnU2U1ZUkvQWFjY0hlNlBHN0RLQkZjWFg0bgorZ1BKbXRvUjk5NVBsenZzTWtxRzdRMUE1MERCM1pZVkUxZzNtRTE1TitNendyRGt3TzhldWZ4SDFLTG5FeGx1ClFFYTZSY3pCeWtRbmd1ZTdBRVNvVXJrZXpjQnlaUlZqaExYa3JjbFJtUEU3dUtZMnlON3EyMUhMa092OXJSbEIKUFY0WjZYelVSUzgyR1FpNUZpc2Z1elI0a2NYTXo5c0JtVzNEN3l4Q1FhRDBxNlQzQjV5QXNyYmorZm11cDdCRApTUkdRRTB1d0FCY1dZOHJMVEhYanpkenI1V0QrTW1jeTFkcWNtVGxpMnNsUW1yaE9ZR1lueXdqcnNpci9oMS9yCm9iSmF1QUlycitiVGQxZW51Q0lOT1hVMUM4OFFYa2QvSVFTTnZYL01PWWV3dUwvVExhdElXeVBpOFB0NVhuVDIKTENTVUpqYlVoMHZDYlNWT29vRGNpTGU5TEdLdkwvR25iczlaRmhnL3BQRERUNFAzV1Zsc0tpczFNcjRQdWpldQpoajgzNXRRUnR1enU2a3RCSjR1cE9hSmtUZmRGOHdJREFRQUJBb0lDQUZvQ1YrYjBCQmZxQUVhaXVZU3lHMUovCnhIbVA5dnF4Ni9pYTVlTGt1T2JCZDZzUTV5Rmp0VXJOOVBzUFdJaU5vT000WVo3QnN4bnZxUmxVK2J6dmRTQS8KbzF0K2pLZ3F6aFdKaVF5ZGMzT0xxVmdwR0RmdkdVbFBiNlE1TmRVZ2lSVkQ0emR3a2VoRzVFclNzOWcyOGNVawpMRUJINWtITGVsdktmaC9HeWh5Q21CT1JWWmZsNEhMeFZTTmZ3eWNGcXEvRFdtd2FvOC90TjJrcDJOa2RHbDlDCmJBRG5Kb1RwOTFpQ1dCY2xhQnczaXIyVW1sSitGWVJJR05VOENYanE5UDlLZFhMSWl3dklFRTNSWGRBV09SZVAKajI0aGpsM0dhQUwzK1hiRlVobVg3VzJqY200WVdTZVFoQU93a2xhMHRWYk5kUDFzY0hUY2x6SXdmTjM2RVBUWQo1Q0wzdDVURTdnaWlRR1JPbEhsdVNQNlJkVjl5VmpqYUZvRHdnNVdpNXNLY1JyaDAxZVM2QzRST1NXRzQ3ekM0CjhKeDcvZS8wYW8rbGdvMTFDRUZMN0ZjR1NxQVZGVXkxQTNwNHhLc3hBc2NldTF4ZE8rcU9PTHNXZnlCcUY3R20KYXAwS0xVS0JtYWg3c2pyUVpqVW1EK1Z5Nk5BTjdHcnNRbHB2ZVhkQU10OURRTHROSUVFbEVRYkFoNGNwT0pqbAplUGswanFaNGdxWEFib0NmbDFWVXY3eS9LblNQQmZLYzZoV1RpZ0NlU2JQaS9UVHlleXpvaHF4ckdTSmoxNkE3CnZaUHJHaVNWSWhFbHdOV25BaExZYmgvY05FY2FMVThDczV2aHhxUVVzcktYc09ORTEzMjNPM2pCbENmUDNDSzcKZVRGQ3E5ZXJjaXV4REtiVmVZYTVBb0lCQVFEeXAwNTN2Wm9oU1dvbHZLS242VEx0VXI2L0RwbG5lVG9EL2JwRQpCbFJqOGxCWFNMZW5RRm53VmtkTUZnRE9JNjFJT1ZSYi9Pb0UyWHVoMVlGeTV0SytBZUo0dG9qTFozQ01LZVp6ClJRZk93dnE2SnMweVhiNzlua2dHckRlR3QzclhBUVk5T003eDRPNDJJWGorS0hveTQ4WThkMUNwWHdJUlRPNmoKYWt3V1pzYnNNOUhIYzBGQ2FVaDBJL0ZNbCtZeGx3OUg5QjFaR2ZFeWE2bk9ZTkFsdkVveHVxc0ZISXE2TTJ6Ygpvc2doQi9tdGZsNVFLUVM5MHhpWUg0bUpYS3Z0RUxQN0wxd2F0YysyZkp6T0RtbXhRNmFWN0dHejhCZy8yeXk1CmJ3U2U4ODZCb20wUEFYWUZDVktIVmxxblZjZ1RyUDAwRkY1bEVqNlVRR1duTVVGM0FvSUJBUURHcStUenRKQ00KK1I4aWVmTjNBci9ibzhjWnYzRzRUZE9xc2V3TVFDODZIMGpYTkFCWDhoOHducHM1NVZXdnB6dnN1alkwRElsZworcWRUblNwbHhOQjRoMm9jeWFZRlJEQUI2SFcwZ3h2V2RteUVtZFo5cWIvT1EyNFlpeGhKc2Z0VTcrTGFVOTY2CjVuaFU1cHBnL1RoeE12YUFhVEtIK0ZDVmQyUlFHMDlJcWhxY2haQWp4KzQyMHVTVHQ0M2FxTnpnekU3WGRwdEIKQ2IzbnpPTlVVRTdRNnRnYStmNmdBM1pNNEJVYXVuL09UZlFaSE5mMjd2dHhERU1sZi8vSzYzZVQwU0QxVG92NwpLRTJLTVFlOCtkQUJKdStYdGU4WjRIMGJWT2N5RGtPcUp1eFFleWlrTHgrcDRJelhlR3prMkhzL1RWZEZhUHptCm1QZ1RWdVhJSjU1bEFvSUJBUURLU2RYdGx0L21QaGpDcXZhQ3VyTWRDKzArdzhINWRDTjhia3FaS1JtelZLL0wKaERDdXVzUC95ejJXM1lVQVZOZkJyU0Y1cW1mQmNUbFRHZlhYdnp3UzhPbEhMd3p0WFNlRGdlNi9TOTROYlppdQpGV2pkUXkvVXFONXN5YWRrcEpOQXFIYjJGT1RZMm1aY05CMTA3SE9xOXg0dERGN3ZRK2dxV2hOYm9tTWFEY1pwCjVXMU9NL1JFbEJhMTA3ejIyRzhzQ2ozUUExOXdCMk4vWUNmb2grY2VmbER3RWlrK2txUElSTlRNYVhFanNFMWkKYUVYaDE4QS9LN3VHSGt4L2VnVk9GYTJsaXI3aStZelhHaDF5M3FzWC8wamlGWFVDRi9kdlRKMkZYVnJoMUdqawp3Mjdkb3A4cjViQ3FhTUFjWGpQMHl6TXU5b2dYQkZXdEs5NVN1b3BUQW9JQkFRQ2FZUXlDUzdkZnRGMzdQbVJ3CkFGVHg2ZXhYRjZyWW1yRjJITmZlRlNvZHNoMjZESkNQeG5keUltMWdxZExSc2RRZytmb1FyQVU4dE1tOWNZMTIKazEranFTWk54R3diLzRhR2xRcVNBS2RyR1k3dDQxVUhSUmJrd3dVVVVWSElRbU9ZOXVlQzNGVmhTcUlLNXo3agpTeUhHNU9Fam01dEdpVENsVktkQWtGZ2xrUGtvMDZqVUJSSVl5L3dPeFQyWHdrd1E2dklCQUF0WW1LZFhMcUVmCjdWK3hmQ3Y5bW5IQUNiQ3R3QnJtTURJTU1Bc1VVSk9KTU45MlV4OENUdHFINWoxL1FheW9zaWFZUGhNeTVUS3MKS0RyNENqZDMza28wQTN0ejk1L0lCOG1RdUxvOU45YTI3bDllZEQwOVdqalVBMXlTTGhrNHVJSjg5alVmWWhFZwpYWmo1QW9JQkFRQ3ZRdjBNUXc4dUs5UEVHbnA3Yk5MTkViYkdlWWVPR3NEVms3WjI3SGlEOVhOUXd3WEppZWcvCkROOEZjZkdpS2k2VVlyTytRZysxV25IYkhCVVRQYjhHN0p3Yjc5Q0NnaXNjaU1SV2dlVThwYzJObDBBWndGNisKZDFZZnJJUmxIWkgvemZoeXY2MFN4TGMyQVBUUUxJczZ2RVNuV3IzMm1VazJKNkhtek5pMTNla2dxL05iODNESgp5T0RXKzJCVnRPUGRvVC80RHMwcXR2Qm5NQkQwVHA2cEdpRGNOdStXeTFvaTJ5Y2JmaFBFcjRSR1l4OVFYYnY3ClEyNjdueDFpeGtLaWRFVklkQ3pOZ2dWVkNUc1dHWEFCWnN6Qi9ONGROVFl1eHhibTdOM0hOYmcrK0JlYXR3L2oKd3BuQVpzcXQzWUlxOGxCS3Juei9KbTRsMzIvRDFST0QKLS0tLS1FTkQgUFJJVkFURSBLRVktLS0tLQo=
---
# Source: ccs/templates/secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: api-config-secret
  namespace: ccs
stringData:
  keycloak.yml: |
    url: "https://keycloak:8443"
    realm: default-domain
    clientId: controller
    admin:
      username: admin
      password: Orbiter@123
      firstname: 
      lastname: 
      email:
---
# Source: ccs/templates/secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: keycloak-admin-creds
  namespace: ccs
stringData:
  password: "admin"
  username: "admin"
type: Opaque
---
# Source: ccs/templates/secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: ccs-postgres-config
  namespace: ccs
stringData:
  DB_PORT: "5432"
  DB_HOST: "ccs-postgresql-cluster"
  POSTGRES_USER: "ccs"
  POSTGRES_PASSWORD: "ccsdbadmin"
---
# Source: ccs/templates/secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: ccs-auditdb-config
  namespace: ccs
stringData:
  AUDITDB_PORT: "5432"
  AUDITDB_USER: "ccs"
  AUDITDB_HOST: "ccs-postgresql-cluster"
  AUDITDB_PASSWORD: "ccsdbadmin"
  AUDITDB_NAME: "audit-db"
---
# Source: ccs/templates/secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: ccs-super-admin-config
  namespace: ccs
stringData:
  super_admin.yaml: |
    admin_users:
    - username: "ccsadmin"
      password: "Welcome@123"
      firstname: "CCS"
      lastname: "Admin"
      email: "info@coredge.io"
---
# Source: ccs/charts/adminServices/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: admin-portal-nginx-conf
  namespace: ccs
data: 
  default.conf: |-
    server {
        listen       80;
        listen       [::]:80;

        proxy_set_header X-Forwarded-For $proxy_protocol_addr; # To forward the original client's IP address
        proxy_set_header X-Forwarded-Proto $scheme; # to forward the  original protocol (HTTP or HTTPS)
        proxy_set_header Host $host;    
        proxy_redirect off;
        server_tokens off;
        proxy_set_header X-Real-IP $http_x_forwarded_for;

        location / {
            root   /usr/share/nginx/html;
            index  index.html index.htm;
            try_files $uri /index.html;
        }
        
        location /adminapi {
            proxy_pass http://orbiter-auth:8060;
            proxy_buffering off;
        }

        location /socket {
            proxy_pass http://orbiter-auth:8060;
            proxy_buffering off;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
            proxy_read_timeout 86400;
        }

        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   /usr/share/nginx/html;
        }
    }
---
# Source: ccs/charts/auth-service/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: orbiter-auth-config
  namespace: ccs
data:
  config.yml: |
    allowCors: true
    keycloak:
      clientId: controller
      introspect:
        clientId: 
        clientSecret: 
    mongoDb:
      host: compass-configdb
      port: 27017
    metricsDb:
      host: compass-metricsdb
      port: 27017
    accessLogs:
      limits:
        maxSize: 1000000 # max memory allowed to be used in bytes for access logs
        maxEntries: 5000 # max number of entries allowed to be used for access logs
    geolocation:
      host: 
      port: 
    gateway:
      rateLimiter:
        rateLimit: 200
        burstSize: 500
    events:
      limits:
        maxSize: 1000000 # max memory allowed to be used in bytes for events per domain
        maxEntries: 5000 # max number of entries allowed to be used for events per domain
    defaultRepos:
      enabled: true
---
# Source: ccs/charts/auth-service/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: gateway-config
  namespace: ccs
data:
  config.yml: |
    http:
      locations:
      - prefix: /api/cloud-manager
        endpoint: http://cloud-manager:8080
        rewritePrefix: /
      - prefix: /api/container-ingress
        endpoint: http://compass-cluster-manager:8060
        accessType: public
        rewritePrefix: /
      - prefix: /api/container-kubeapi
        endpoint: http://compass-cluster-manager:8060
        accessType: unscoped
      - prefix: /api/cluster-manager/v1/domain
        endpoint: http://compass-cluster-manager:8080
        rewritePrefix: /v1/domain
      - prefix: /api/cluster-manager/v1
        endpoint: http://compass-cluster-manager:8080
        rewritePrefix: /v1
        accessType: unscoped
      - prefix: /api/cluster-manager/v1/download
        endpoint: http://compass-cluster-manager:8080
        rewritePrefix: /v1/download
        accessType: public
      - prefix: /api/slurmrest
        endpoint: http://compass-cluster-manager:8085
        rewritePrefix: /
      - prefix: /api/orchestrator
        endpoint: http://compass-orchestrator:8080
      - prefix: /api/auth-mgmt
        consumeLocally: true
        allowRootTenantOnly: true
      - prefix: /api/auth-service
        consumeLocally: true
      - prefix: /api/auth-service/v1/download
        consumeLocally: true
        accessType: public
      - prefix: /api/accessibility
        consumeLocally: true
        accessType: unscoped
      - prefix: /api/ingress
        endpoint: http://compass-api:8071
        rewritePrefix: /
      - prefix: /ws/terminal
        endpoint: http://compass-term:8000
        rewritePrefix: /
      - prefix: /ws/robincli
        endpoint: http://compass-term:8001
        rewritePrefix: /
      - prefix: /ws/compass
        endpoint: http://compass-api:9080
      - prefix: /api/license
        endpoint: http://orbiter-metering:8080
      - prefix: /api/metering
        endpoint: http://orbiter-metering:8080
      - prefix: /v1/download
        endpoint: http://compass-api:8085
        accessType: public
      - prefix: /v1
        endpoint: http://compass-api:8085
      - prefix: /
        endpoint: http://compass-api:8085
        accessType: public
      - prefix: /api/myaccount
        consumeLocally: true
        accessType: unscoped
---
# Source: ccs/charts/cloud-manager/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: cloud-manager-config
  namespace: ccs
data:
  config.yml: |
    mongodb:
      host: compass-configdb
      port: 27017
    metricsdb:
      host: compass-metricsdb
      port: 27017
    events:
      limits:
        maxSize: 1000000 # max memory allowed to be used in bytes for events per domain
        maxEntries: 5000 # max number of entries allowed to be used for events per domain
    cloudAccount:
      healthcheckInterval: 300 # value for health check interval (in seconds)
    s3Endpoint:
      healthCheckInterval: 300
---
# Source: ccs/charts/grafana/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: ccs-grafana
  namespace: ccs
  labels:
    helm.sh/chart: grafana-6.52.1
    app.kubernetes.io/name: grafana
    app.kubernetes.io/instance: ccs
    app.kubernetes.io/version: "9.4.3"
    app.kubernetes.io/managed-by: Helm
data:
  grafana.ini: |
    [analytics]
    check_for_updates = true
    [auth.anonymous]
    enabled = true
    [grafana_net]
    url = https://grafana.net
    [log]
    mode = console
    [paths]
    data = /var/lib/grafana/
    logs = /var/log/grafana
    plugins = /var/lib/grafana/plugins
    provisioning = /etc/grafana/provisioning
    [security]
    allow_embedding = true
    [server]
    domain = ''
    root_url = %(protocol)s://%(domain)s:%(http_port)s/api/grafana/
    serve_from_sub_path = true
---
# Source: ccs/charts/keycloak-ha/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: keycloak-extra-envs
data:
  KC_DB_POOL_INITIAL_SIZE: "10"
  KC_DB_POOL_MIN_SIZE: "20"
  KC_DB_POOL_MAX_SIZE: "100"
---
# Source: ccs/charts/metering/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: orbiter-metering-config
  namespace: ccs
data:
  config.yml: |
    mongodb:
      host: compass-configdb
      port: 27017
    metricsdb:
      host: compass-metricsdb
      port: 27017
    events:
      limits:
        maxSize: 1000000 # max memory allowed to be used in bytes for events per domain
        maxEntries: 5000 # max number of entries allowed to be used for events per domain
---
# Source: ccs/charts/userPortal/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: user-portal-tcp-config
  namespace: ccs
data:
  default.conf: |-
    server {
        listen     6443;
        proxy_pass compass-api:6443;
    }
    server {
        listen     8030;
        proxy_pass compass-controller:8030;
    }
    server {
        listen     8040;
        proxy_pass compass-controller:8040;
    }
---
# Source: ccs/charts/userPortal/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: user-portal-config
  namespace: ccs
data:
  default.conf: |-
    map $http_upgrade $connection_upgrade {
        default upgrade;
        ''      close;
    }
    server {
        listen       80;
        listen       [::]:80;
        server_name  _;
        client_max_body_size 2M;
        proxy_busy_buffers_size   128k;
        proxy_buffers   64 64k;
        proxy_buffer_size   128k;

        proxy_set_header X-Forwarded-For $proxy_protocol_addr; # To forward the original client's IP address
        proxy_set_header X-Forwarded-Proto $scheme; # to forward the  original protocol (HTTP or HTTPS)
        proxy_set_header Host $host:32500; # to forward the original host requested by the client

        location / {
            root   /usr/share/nginx/html;
            index  index.html index.htm;
            try_files $uri /index.html;
            add_header 'Cache-Control' 'no-store, no-cache, max-age=10';
        }

        location /dbaas {
            rewrite ^/dbaas(.*) /v1$1  break;
            proxy_pass  http://orbiter-auth:8060;
            add_header 'Cache-Control' 'no-store, no-cache, max-age=10';
        }

        location /auth/resources {
            proxy_pass http://keycloak:8080;
            add_header 'Cache-Control' 'no-store, no-cache, max-age=10';
        }

        location /auth/realms/master {
            deny all;
        }

        location /api/auth-service {
            proxy_pass  http://orbiter-auth:8060;
            add_header 'Cache-Control' 'no-store, no-cache, max-age=10';
        }

        location /auth/realms {
            proxy_pass http://keycloak:8080;
            add_header 'Cache-Control' 'no-store, no-cache, max-age=10';
        }

        location /api/grafana {
            proxy_pass  http://compass-api:8081;
        }
        location /api/compass {
            rewrite ^/api/compass/(.*) /$1  break;
            proxy_pass  http://orbiter-auth:8060;
            add_header 'Cache-Control' 'no-store, no-cache, max-age=10';
        }

        location /api/ingress {
            proxy_pass  http://orbiter-auth:8060;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
            proxy_set_header Host $host;
            proxy_cache_bypass $http_upgrade;
            proxy_read_timeout 3600s;
            proxy_send_timeout 3600s;
        }

        location /api/kubeapi {
            rewrite ^/api/kubeapi/(.*) /$1  break;
            proxy_pass  http://compass-api:8070;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection $connection_upgrade;
            proxy_read_timeout 3600s;
            proxy_send_timeout 3600s;
        }

        location /api/container-kubeapi {
            proxy_pass  http://orbiter-auth:8060;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection $connection_upgrade;
            proxy_read_timeout 3600s;
            proxy_send_timeout 3600s;
        }
        
        location /api/pc-ingress {
            rewrite ^/api/pc-ingress/(.*) /$1  break;
            proxy_pass  http://compass-api:8061;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection $connection_upgrade;
            proxy_read_timeout 3600s;
            proxy_send_timeout 3600s;
        }

        location /api/container-ingress {
            proxy_pass  http://orbiter-auth:8060;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection $connection_upgrade;
            proxy_read_timeout 3600s;
            proxy_send_timeout 3600s;
        }

        location /api {
            proxy_pass  http://orbiter-auth:8060;
            add_header 'Cache-Control' 'no-store, no-cache, max-age=10';
        }

        location /socket {
            proxy_pass  http://orbiter-auth:8060;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
            proxy_set_header Host $host;
            proxy_cache_bypass $http_upgrade;
            proxy_read_timeout 3600s;
            proxy_send_timeout 3600s;
        }

        location /ws {
            proxy_pass  http://orbiter-auth:8060;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
            proxy_set_header Host $host;
            proxy_cache_bypass $http_upgrade;
            proxy_read_timeout 3600s;
            proxy_send_timeout 3600s;
        }

        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   /usr/share/nginx/html;
        }
    }
---
# Source: ccs/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: api-config
  namespace: ccs
data:
  config.yml: |
    gateway:
      port: 8060
      rateLimiter:
        rateLimit: 200
        burstSize: 500
    geolocation:
      host: 
      port: 
    saas:
      enabled: false
    grafana:
      enabled: false
      endpoint: ccs-grafana.ccs
    api:
      externalIP: 127.0.0.1
      port: 8090
      ingressPort: 8070
      centralIngressPort: 8071
      allowCORS: true
      auth:
        enabled: true
        provider: http://127.0.0.1:
        realm: default-domain
        clientId: controller
      agent:
        image: ""
        imageRepo: ""
        hostNetwork: true
    proxyProtocol:
      enabled: false
    tenantManagement:
      enabled: false
    accessLogs:
      limits:
        maxSize: 1000000 # max memory allowed to be used in bytes for access logs
        maxEntries: 5000 # max number of entries allowed to be used for access logs
    cluster:
      accessLogs:
        enabled: true
        limits:
          maxSize: 1000000 # max memory allowed to be used in bytes for cluster access logs per cluster
          maxEntries: 5000 # max number of entries allowed to be used for cluster access logs per cluster
    events:
      limits:
        maxSize: 1000000 # max memory allowed to be used in bytes for events per domain
        maxEntries: 5000 # max number of entries allowed to be used for events per domain
    controller:
      externalIP: "127.0.0.1"
      domainName: ""
      port: 8040
      bootstrapPort: 8030
      internalGatewayPort: 8090
      mTLSDisabled: false
    mongodb:
      host: compass-configdb
      port: 27017
    metricsdb:
      host: compass-metricsdb
      port: 27017
    redisdb:
      host: notification-store
      port: 6380
    certificates:
      rootCA:
        cert: "/opt/certs/rootCA.pem"
        key: "/opt/certs/rootCA.key"
    defaultRepos:
      enabled: true
    marketPlace:
      url:
---
# Source: ccs/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: controller-config
  namespace: ccs
data:
  config.yml: |
    controller:
      port: 8040
      internalGatewayPort: 8090
      ingressPort: 6443
      bootstrapPort: 8030
      externalIP: "127.0.0.1"
      proxyIPs:
      - "127.0.0.1"
      - "::1"
      domainName: ""
      mTLSDisabled: false
      hostAgent:
        url: http://127.0.0.1:32500/api/cluster-manager/v1/download/compass-host-agent
    proxyProtocol:
      enabled: false
    mongodb:
      host: compass-configdb
      port: 27017
    metricsdb:
      host: compass-metricsdb
      port: 27017
    certificates:
      client:
        certValidity: 5
      rootCA:
        cert: "/opt/certs/rootCA.pem"
        key: "/opt/certs/rootCA.key"
      ingress:
        cert: "/opt/certs/ingress/cert.pem"
        key: "/opt/certs/ingress/key.pem"
---
# Source: ccs/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: terminal-config
  namespace: ccs
data:
  config.yml: |
    term:
      port: 8000
      auth:
        enabled: true
        provider: http://127.0.0.1:32500
        realm: default-domain
        clientId: controller
    mongodb:
      host: compass-configdb
      port: 27017
    metricsdb:
      host: compass-metricsdb
      port: 27017
    certificates:
      ingress:
        cert: "/opt/certs/ingress/cert.pem"
---
# Source: ccs/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: kg-cluster-config
  namespace: ccs
data:
  config.yml: |
    mongodb:
      host: compass-configdb
      port: 27017
    metricsdb:
      host: compass-metricsdb
      port: 27017
    certificates:
      ingress:
        cert: "/opt/certs/ingress/cert.pem"
    kgApp:
      endpoint: "kgapp-service:5555"
---
# Source: ccs/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: orchestrator-config
  namespace: ccs
data:
  config.yml: |
    mongodb:
      host: compass-configdb
      port: 27017
    metricsdb:
      host: compass-metricsdb
      port: 27017
    appInstanceLogs:
      limits:
        maxSize: 50000 # assuming each log entry to be of 1000 bytes, for 50 max entries, the size limit will be 50*1000
        maxEntries: 50 # max number of entries allowed to be used for orchestrator logs per appInstance
---
# Source: ccs/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: metric-server-config
  namespace: ccs
data:
  config.yml: |
    mongodb:
      host: compass-configdb
      port: 27017
    metricsdb:
      host: compass-metricsdb
      port: 27017
    events:
      limits:
        maxSize: 1000000 # max memory allowed to be used in bytes for events per domain
        maxEntries: 5000 # max number of entries allowed to be used for events per domain
    geolocation:
      host: 
      port:
---
# Source: ccs/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: image-scanner-config
  namespace: ccs
data:
  config.yml: |
    mongodb:
      host: compass-configdb
      port: 27017
---
# Source: ccs/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: trivy-config
  namespace: ccs
data:
  trivy.yml: |
    trivy:
      defaultServer:
        hostName: 
        port: 4954
        scheme: https
        allowInsecure: false
        customHeaders:
        - name: Trivy-Token
          values:
          -
---
# Source: ccs/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: mongo-init
  namespace: ccs
data:
  start-mongodb.sh: |
    #!/bin/bash
    cp /opt/auth /tmp/auth
    chmod 400 /tmp/auth
    REPLICA_COUNT=${REPLICA_COUNT:-1}
    REPLICA_NAME=${REPLICA_NAME:-compass-configdb}
    PODNAME=$(hostname -f | awk '{split($0,a,"."); print a[1]}')
    SUBDOMAIN=$(hostname -f | awk '{split($0,a,"."); print a[2]}')
    export HOSTNAME=$(echo $PODNAME"."$SUBDOMAIN)
    export HOME=/tmp
    cat << EOF > /tmp/mongo-exec.sh
    # wait for mongod to start
    sleep 30
    EOF
    # execute rs.initiate only on replica id 0
    if [ "$PODNAME" == "$SUBDOMAIN-0" ]; then
        cat << EOF >> /tmp/mongo-config.js
    conf = rs.conf()
    conf.members[0].priority = 5
    rs.reconfig(conf, {"force":true})
    conf.members[0].priority = 10
    rs.reconfig(conf, {"force":true})
    EOF
        cat << EOF >> /tmp/mongo-exec.sh
    mongosh --host 127.0.0.1 -u \$MONGO_INITDB_ROOT_USERNAME -p \$MONGO_INITDB_ROOT_PASSWORD --eval 'rs.initiate(
       {
          _id: "${REPLICA_NAME}",
          version: 1,
          members: [
             { _id: 0, priority: 10, host : "${HOSTNAME}:27017" },
          ]
       }
  
    )'
    sleep 10
    mongosh --host 127.0.0.1 -u \$MONGO_INITDB_ROOT_USERNAME -p \$MONGO_INITDB_ROOT_PASSWORD < /tmp/mongo-config.js
    EOF
    else
        cat << EOF >> /tmp/mongo-exec.sh
    mongosh --host $SUBDOMAIN-0.${SUBDOMAIN} -u \$MONGO_INITDB_ROOT_USERNAME -p \$MONGO_INITDB_ROOT_PASSWORD --eval 'rs.add(
       {
          host: "${HOSTNAME}:27017"
       }
    )'
    EOF
    fi
    bash /tmp/mongo-exec.sh &
    eval docker-entrypoint.sh --ipv6 --replSet ${REPLICA_NAME} --keyFile /tmp/auth
---
# Source: ccs/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: platform-api-config
  namespace: ccs
data:
  DB_COLOCATION_ENABLED: "false"
  COMPUTE_API_URL: "http://compute-service:7110/api/v1"
  VOLUME_API_URL: "http://volume-service:7120/api/v1"
  CORE_MGMT_API_URL: "http://core-mgmt:7150/api/v1"
  BASE_NETWORK_API_URL: "http://neutron-service:7160/api/v1"
  LOAD_BALANCER_BASE_URL: "http://neutron-service:7160/api/v1"
  CERTIFICATE_API_URL: "http://certificates-manager:7140/api/v1"
  AUTOSCALING_API_URL: 'http://autoscaling-service:7181/api/v1'
  BACKUP_API_URL: 'http://commvault:7030/api/v1'
  NOTIFICATION_URL: 'http://notification:5000'
  SCHEDULER_URL: 'http://scheduler:5003'
  TENANT_FIREWALL_API_URL: 'http://ccp-firewall:7180/api/v1'
  ADMIN_API_URL: 'http://admin-platform:5000'
  SCHEDULER_BASE_API_URL: 'http://scheduler:5003'
  INIT_PROVIDER_LIST: 
  APPLICATION:
---
# Source: ccs/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: redis-config
  namespace: ccs
data:
  REDIS_HOST: 'cache-store'
  REDIS_PORT: '6379'
---
# Source: ccs/charts/grafana/templates/pvc.yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: ccs-grafana
  namespace: ccs
  labels:
    helm.sh/chart: grafana-6.52.1
    app.kubernetes.io/name: grafana
    app.kubernetes.io/instance: ccs
    app.kubernetes.io/version: "9.4.3"
    app.kubernetes.io/managed-by: Helm
  finalizers:
    - kubernetes.io/pvc-protection
spec:
  accessModes:
    - "ReadWriteOnce"
  resources:
    requests:
      storage: "10Gi"
---
# Source: ccs/charts/grafana/templates/clusterrole.yaml
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  labels:
    helm.sh/chart: grafana-6.52.1
    app.kubernetes.io/name: grafana
    app.kubernetes.io/instance: ccs
    app.kubernetes.io/version: "9.4.3"
    app.kubernetes.io/managed-by: Helm
  name: ccs-grafana-clusterrole
rules: []
---
# Source: ccs/charts/postgres-operator/templates/clusterrole-postgres-pod.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: postgres-pod
  labels:
    app.kubernetes.io/name: postgres-operator
    helm.sh/chart: postgres-operator-1.12.2
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/instance: ccs
rules:
# Patroni needs to watch and manage config maps or endpoints
- apiGroups:
  - ""
  resources:
  - endpoints
  verbs:
  - create
  - delete
  - deletecollection
  - get
  - list
  - patch
  - update
  - watch
# Patroni needs to watch pods
- apiGroups:
  - ""
  resources:
  - pods
  verbs:
  - get
  - list
  - patch
  - update
  - watch
# to let Patroni create a headless service
- apiGroups:
  - ""
  resources:
  - services
  verbs:
  - create
---
# Source: ccs/charts/postgres-operator/templates/clusterrole.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: postgresql-operator
  labels:
    app.kubernetes.io/name: postgres-operator
    helm.sh/chart: postgres-operator-1.12.2
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/instance: ccs
rules:
# all verbs allowed for custom operator resources
- apiGroups:
  - acid.zalan.do
  resources:
  - postgresqls
  - postgresqls/status
  - operatorconfigurations
  verbs:
  - create
  - delete
  - deletecollection
  - get
  - list
  - patch
  - update
  - watch
# operator only reads PostgresTeams
- apiGroups:
  - acid.zalan.do
  resources:
  - postgresteams
  verbs:
  - get
  - list
  - watch
# all verbs allowed for event streams
# to create or get/update CRDs when starting up
- apiGroups:
  - apiextensions.k8s.io
  resources:
  - customresourcedefinitions
  verbs:
  - get
  - create
  - patch
  - update
# to send events to the CRs
- apiGroups:
  - ""
  resources:
  - events
  verbs:
  - create
  - get
  - list
  - patch
  - update
  - watch
# to manage endpoints/configmaps which are also used by Patroni
# to read configuration from ConfigMaps
- apiGroups:
  - ""
  resources:
  - configmaps
  verbs:
  - get
- apiGroups:
  - ""
  resources:
  - endpoints
  verbs:
  - create
  - delete
  - deletecollection
  - get
  - list
  - patch
  - update
  - watch
# to CRUD secrets for database access
- apiGroups:
  - ""
  resources:
  - secrets
  verbs:
  - create
  - delete
  - get
  - update
# to check nodes for node readiness label
- apiGroups:
  - ""
  resources:
  - nodes
  verbs:
  - get
  - list
  - watch
# to read or delete existing PVCs. Creation via StatefulSet
- apiGroups:
  - ""
  resources:
  - persistentvolumeclaims
  verbs:
  - delete
  - get
  - list
  - patch
  - update
 # to read existing PVs. Creation should be done via dynamic provisioning
- apiGroups:
  - ""
  resources:
  - persistentvolumes
  verbs:
  - get
  - list
# to watch Spilo pods and do rolling updates. Creation via StatefulSet
- apiGroups:
  - ""
  resources:
  - pods
  verbs:
  - delete
  - get
  - list
  - patch
  - update
  - watch
# to resize the filesystem in Spilo pods when increasing volume size
- apiGroups:
  - ""
  resources:
  - pods/exec
  verbs:
  - create
# to CRUD services to point to Postgres cluster instances
- apiGroups:
  - ""
  resources:
  - services
  verbs:
  - create
  - delete
  - get
  - patch
  - update
# to CRUD the StatefulSet which controls the Postgres cluster instances
- apiGroups:
  - apps
  resources:
  - statefulsets
  - deployments
  verbs:
  - create
  - delete
  - get
  - list
  - patch
# to CRUD cron jobs for logical backups
- apiGroups:
  - batch
  resources:
  - cronjobs
  verbs:
  - create
  - delete
  - get
  - list
  - patch
  - update
# to get namespaces operator resources can run in
- apiGroups:
  - ""
  resources:
  - namespaces
  verbs:
  - get
# to define PDBs. Update happens via delete/create
- apiGroups:
  - policy
  resources:
  - poddisruptionbudgets
  verbs:
  - create
  - delete
  - get
# to create ServiceAccounts in each namespace the operator watches
- apiGroups:
  - ""
  resources:
  - serviceaccounts
  verbs:
  - get
  - create
# to create role bindings to the postgres-pod service account
- apiGroups:
  - rbac.authorization.k8s.io
  resources:
  - rolebindings
  verbs:
  - get
  - create
---
# Source: ccs/charts/grafana/templates/clusterrolebinding.yaml
kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: ccs-grafana-clusterrolebinding
  labels:
    helm.sh/chart: grafana-6.52.1
    app.kubernetes.io/name: grafana
    app.kubernetes.io/instance: ccs
    app.kubernetes.io/version: "9.4.3"
    app.kubernetes.io/managed-by: Helm
subjects:
  - kind: ServiceAccount
    name: ccs-grafana
    namespace: ccs
roleRef:
  kind: ClusterRole
  name: ccs-grafana-clusterrole
  apiGroup: rbac.authorization.k8s.io
---
# Source: ccs/charts/postgres-operator/templates/clusterrolebinding.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: postgresql-operator
  labels:
    app.kubernetes.io/name: postgres-operator
    helm.sh/chart: postgres-operator-1.12.2
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/instance: ccs
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: postgresql-operator
subjects:
- kind: ServiceAccount
  name: postgresql-operator
  namespace: ccs
---
# Source: ccs/charts/grafana/templates/role.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: ccs-grafana
  namespace: ccs
  labels:
    helm.sh/chart: grafana-6.52.1
    app.kubernetes.io/name: grafana
    app.kubernetes.io/instance: ccs
    app.kubernetes.io/version: "9.4.3"
    app.kubernetes.io/managed-by: Helm
rules: []
---
# Source: ccs/charts/keycloak-ha/templates/postgresql-rbac.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: keycloak-postgresql-operator
  namespace: ccs
rules:
# all verbs allowed for custom operator resources
- apiGroups:
  - acid.zalan.do
  resources:
  - postgresqls
  - postgresqls/status
  verbs:
  - delete
  - get
  - list
  - patch
  - update
  - watch
# to CRUD services to point to Postgres cluster instances
- apiGroups:
  - ""
  resources:
  - services
  verbs:
  - delete
  - get
  - patch
  - update
  - list
- apiGroups:
  - ""
  resources:
  - pods
  verbs:
  - delete
  - get
  - list
  - patch
  - update
  - watch
---
# Source: ccs/charts/keycloak-ha/templates/role.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: keycloak
  namespace: ccs
rules:
- apiGroups: ["*"]
  resources: ["pods"]
  verbs: ["get", "list", "watch"]
---
# Source: ccs/templates/postgresql-ha/rbac.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: ccp-postgresql-operator
  namespace: ccs
rules:
# all verbs allowed for custom operator resources
- apiGroups:
  - acid.zalan.do
  resources:
  - postgresqls
  - postgresqls/status
  verbs:
  - delete
  - get
  - list
  - patch
  - update
  - watch
# to CRUD services to point to Postgres cluster instances
- apiGroups:
  - ""
  resources:
  - services
  verbs:
  - delete
  - get
  - patch
  - update
  - list
- apiGroups:
  - ""
  resources:
  - pods
  verbs:
  - delete
  - get
  - list
  - patch
  - update
  - watch
---
# Source: ccs/templates/rbac.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: ccs-compass-controller
  namespace: ccs
rules:
- apiGroups:
  - '*'
  resources:
  - '*'
  verbs:
  - '*'
---
# Source: ccs/charts/grafana/templates/rolebinding.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: ccs-grafana
  namespace: ccs
  labels:
    helm.sh/chart: grafana-6.52.1
    app.kubernetes.io/name: grafana
    app.kubernetes.io/instance: ccs
    app.kubernetes.io/version: "9.4.3"
    app.kubernetes.io/managed-by: Helm
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: ccs-grafana
subjects:
- kind: ServiceAccount
  name: ccs-grafana
  namespace: ccs
---
# Source: ccs/charts/keycloak-ha/templates/postgresql-rbac.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: keycloak-postgresql-operator
  namespace: ccs
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: keycloak-postgresql-operator
subjects:
- kind: ServiceAccount
  name: keycloak-postgresql-operator
  namespace: ccs
---
# Source: ccs/charts/keycloak-ha/templates/rolebinding.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  annotations:
    name: keycloak
  name: keycloak
  namespace: ccs
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: keycloak
subjects:
- kind: ServiceAccount
  name: keycloak
  namespace: ccs
---
# Source: ccs/templates/postgresql-ha/rbac.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: ccp-postgresql-operator
  namespace: ccs
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: ccp-postgresql-operator
subjects:
- kind: ServiceAccount
  name: ccp-postgresql-operator
  namespace: ccs
---
# Source: ccs/templates/rbac.yaml
kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: ccs-compass-controller
  namespace: ccs
subjects:
- kind: ServiceAccount
  name: compass-controller
  namespace: ccs
roleRef:
  kind: ClusterRole
  name: ccs-compass-controller
  apiGroup: rbac.authorization.k8s.io
---
# Source: ccs/charts/adminServices/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: admin-portal
  namespace: ccs
  labels:
    app: admin-portal
spec:
  type: NodePort
  ports:
  - port: 80
    targetPort: 80
    protocol: TCP
    nodePort: 32600
  selector:
    app: admin-portal
---
# Source: ccs/charts/adminServices/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: admin-platform
  namespace: ccs
  labels:
    app: admin-platform
spec:
  type: ClusterIP
  ports:
  - port: 5000
    targetPort: 5000
    protocol: TCP
    name: http
  selector:
    app: admin-platform
---
# Source: ccs/charts/adminServices/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: admin-platform-celery
  namespace: ccs
  labels:
    app: admin-platform-celery
spec:
  type: ClusterIP
  ports:
  - port: 5000
    targetPort: 5000
    protocol: TCP
    name: http
  selector:
    app: admin-platform-celery
---
# Source: ccs/charts/auth-service/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: orbiter-auth
  namespace: ccs
spec:
  selector:
    orbiter.coredge.io: auth
  ports:
  - protocol: TCP
    port: 8060
    targetPort: 8060
    name: auth
  - protocol: TCP
    port: 8080
    targetPort: 8080
    name: api
---
# Source: ccs/charts/autoscalingService/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: autoscaling-service
  namespace: ccs
  labels:
    app: autoscaling-service
spec:
  type: ClusterIP
  ports:
  - port: 7181
    targetPort: 5000
    protocol: TCP
    name: http
  selector:
      app: autoscaling-service
---
# Source: ccs/charts/autoscalingService/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: autoscaling-service-celery
  namespace: ccs
  labels:
    app: autoscaling-service-celery
spec:
  type: ClusterIP
  ports:
  - port: 7181
    targetPort: 5000
    protocol: TCP
    name: http
  selector:
      app: autoscaling-service-celery
---
# Source: ccs/charts/cloud-manager/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: cloud-manager
  namespace: ccs
  labels:
    app: cloud-manager
spec:
  ports:
  - name: http
    port: 8080
    targetPort: 8080
    protocol: TCP
  selector:
    app: cloud-manager
---
# Source: ccs/charts/computeService/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: compute-service
  namespace: ccs
  labels:
    app: compute-service
spec:
  type: ClusterIP
  ports:
  - port: 7110
    targetPort: 5000
    protocol: TCP
  selector:
      app: compute-service
---
# Source: ccs/charts/computeService/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: compute-service-celery
  namespace: ccs
  labels:
    app: compute-service-celery
spec:
  type: ClusterIP
  ports:
  - port: 7110
    targetPort: 5000
    protocol: TCP
  selector:
      app: compute-service-celery
---
# Source: ccs/charts/coremgmtService/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: core-mgmt
  namespace: ccs
  labels:
    app: core-mgmt
spec:
  type: ClusterIP
  ports:
  - port: 7150
    targetPort: 5000
    protocol: TCP
    name: http
  selector:
      app: core-mgmt
---
# Source: ccs/charts/coremgmtService/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: core-mgmt-celery
  namespace: ccs
  labels:
    app: core-mgmt-celery
spec:
  type: ClusterIP
  ports:
  - port: 7150
    targetPort: 5000
    protocol: TCP
    name: http
  selector:
      app: core-mgmt-celery
---
# Source: ccs/charts/grafana/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: ccs-grafana
  namespace: ccs
  labels:
    helm.sh/chart: grafana-6.52.1
    app.kubernetes.io/name: grafana
    app.kubernetes.io/instance: ccs
    app.kubernetes.io/version: "9.4.3"
    app.kubernetes.io/managed-by: Helm
spec:
  type: ClusterIP
  ports:
    - name: service
      port: 80
      protocol: TCP
      targetPort: 3000
  selector:
    app.kubernetes.io/name: grafana
    app.kubernetes.io/instance: ccs
---
# Source: ccs/charts/keycloak-ha/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: keycloak
  namespace: ccs
  labels:
    app: keycloak
spec:
  ports:
  - name: http
    port: 80
    targetPort: 8080
    protocol: TCP
    nodePort: 32701
  - name: https
    port: 8443
    targetPort: 8443
    protocol: TCP
    nodePort: 32702
  selector:
    app: keycloak
  type: NodePort
---
# Source: ccs/charts/keycloak-ha/templates/service.yaml
# headless-svc.yml
apiVersion: v1
kind: Service
metadata:
  name: keycloak-headless
  namespace: ccs
spec:
  type: ClusterIP
  clusterIP: None
  selector:
    app: keycloak
  ports:
  - name: http
    protocol: TCP
    port: 80
    targetPort: 8080
  - name: https
    protocol: TCP
    port: 8443
    targetPort: 8443
---
# Source: ccs/charts/metering/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: orbiter-metering
  namespace: ccs
  labels:
    app: orbiter-metering
spec:
  ports:
  - name: http
    port: 8080
    targetPort: 8080
    protocol: TCP
  - name: websocket
    port: 9080
    targetPort: 9080
    protocol: TCP
  - name: ccp
    port: 8081
    targetPort: 8081
    protocol: TCP
  selector:
    app: orbiter-metering
---
# Source: ccs/charts/neutronService/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: neutron-service
  namespace: ccs
  labels:
    app: neutron-service
spec:
  type: ClusterIP
  ports:
  - port: 7160
    targetPort: 5000
    protocol: TCP
    name: http
  selector:
      app: neutron-service
---
# Source: ccs/charts/neutronService/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: neutron-service-celery
  namespace: ccs
  labels:
    app: neutron-service-celery
spec:
  type: ClusterIP
  ports:
  - port: 7160
    targetPort: 5000
    protocol: TCP
    name: http
  selector:
      app: neutron-service-celery
---
# Source: ccs/charts/postgres-operator/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  labels:
    app.kubernetes.io/name: postgres-operator
    helm.sh/chart: postgres-operator-1.12.2
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/instance: ccs
  name: ccs-postgres-operator
  namespace: ccs
spec:
  type: ClusterIP
  ports:
  - port: 8080
    protocol: TCP
    targetPort: 8080
  selector:
    app.kubernetes.io/instance: ccs
    app.kubernetes.io/name: postgres-operator
---
# Source: ccs/charts/userPortal/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: user-portal
  namespace: ccs
spec:
  ports:
  - name: kubectl
    port: 6443
    targetPort: 6443
  - name: http
    port: 80
    targetPort: 80
    nodePort: 32500
  type: NodePort

  selector:
    app: user-portal
---
# Source: ccs/charts/volumeService/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: volume-service
  namespace: ccs
  labels:
    app: volume-service
spec:
  type: ClusterIP
  ports:
  - port: 7120
    targetPort: 5000
    protocol: TCP
    name: http
  selector:
      app: volume-service
---
# Source: ccs/charts/volumeService/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: volume-service-celery
  namespace: ccs
  labels:
    app: volume-service-celery
spec:
  type: ClusterIP
  ports:
  - port: 7120
    targetPort: 5000
    protocol: TCP
    name: http
  selector:
      app: volume-service-celery
---
# Source: ccs/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: compass-configdb
  namespace: ccs
  annotations:
spec:
  type: ClusterIP
  ports:
    - name: mongodb
      port: 27017
      targetPort: 27017
      protocol: TCP
  selector:
      app: configdb
---
# Source: ccs/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: configdb
  namespace: ccs
spec:
  type: ClusterIP
  clusterIP: None
  ports:
    - port: 27017
      targetPort: 27017
      protocol: TCP
  selector:
      app: configdb
---
# Source: ccs/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: compass-metricsdb
  namespace: ccs
  annotations:
spec:
  type: ClusterIP
  ports:
    - name: mongodb
      port: 27017
      targetPort: 27017
      protocol: TCP
  selector:
      app: metricsdb
---
# Source: ccs/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: metricsdb
  namespace: ccs
spec:
  type: ClusterIP
  clusterIP: None
  ports:
    - port: 27017
      targetPort: 27017
      protocol: TCP
  selector:
      app: metricsdb
---
# Source: ccs/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: compass-api
  namespace: ccs
  labels:
    app: compass-api
spec:
  ports:
    - name: ingress
      port: 8070
      targetPort: 8070
    - name: central-ingress
      port: 8071
      targetPort: 8071
    - name: provider
      port: 8061
      targetPort: 8061
    - port: 6443
      name: kubectl
      targetPort: 6443
    - port: 8085
      name: insecure-api
      targetPort: 8085
    - name: websocket
      port: 9080
      targetPort: 9080
    - name: insecure-central-ingress
      port: 8080
      targetPort: 8080
    - name: grafana
      port: 8081
      targetPort: 8081
  selector:
    app: compass-api
---
# Source: ccs/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: compass-controller
  namespace: ccs
  labels:
    app: compass-controller
spec:
  ports:
    - port: 8030
      name: bootstrap
      targetPort: 8030
      protocol: TCP
    - port: 8040
      name: controller
      targetPort: 8040
      protocol: TCP
  selector:
    app: compass-controller
  type: NodePort
---
# Source: ccs/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: compass-ingress
  namespace: ccs
  labels:
    app: compass-controller
spec:
  ports:
    - port: 443
      name: ingress
      targetPort: 6443
      protocol: TCP
  selector:
    app: compass-controller
  type: ClusterIP
---
# Source: ccs/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: compass-orchestrator
  namespace: ccs
  labels:
    app: compass-orchestrator
spec:
  ports:
    - port: 8080
      name: http
      targetPort: 8080
    - port: 8081
      name: http-internal-ccp
      targetPort: 8081
  selector:
    app: compass-orchestrator
---
# Source: ccs/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: compass-term
  namespace: ccs
  labels:
    app: compass-term
spec:
  type: ClusterIP
  ports:
    - name: websocket
      port: 8000
      targetPort: 8000
    - name: robin-websocket
      port: 8001
      targetPort: 8001
  selector:
    app: compass-term
---
# Source: ccs/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: internal-cluster-api
  namespace: ccs
  labels:
    app: internal-cluster-api
spec:
  type: ClusterIP
  ports:
    - port: 7080
      targetPort: 7080
      name: http
  selector:
    app: kg-cluster-notifier
---
# Source: ccs/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: metric-server
  namespace: ccs
  annotations:
    prometheus.io/path: metrics
    prometheus.io/port: "9100"
    prometheus.io/scrape: "true"
  labels:
    app: compass-metric-server
spec:
  ports:
    - port: 9100
      name: metric
      targetPort: 9100
  selector:
    app: compass-metric-server
---
# Source: ccs/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: compass-cluster-manager
  namespace: ccs
  labels:
    app: compass-cluster-manager
spec:
  ports:
    - name: http
      port: 8080
      targetPort: 8080
    - name: internalgrpc
      port: 8070
      targetPort: 8070
    - name: slurmrest
      port: 8085
      targetPort: 8085
    - name: container-kubeapi
      port: 8060
      targetPort: 8060
  selector:
    app: compass-cluster-manager
---
# Source: ccs/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: notification-store
spec:
  type: ClusterIP
  ports:
    - port: 6380
      targetPort: 6379
      protocol: TCP
  selector:
      app: notification-store
---
# Source: ccs/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: cache-store
  namespace: ccs
  labels:
    app: cache-store
spec:
  type: ClusterIP
  ports:
  - port: 6379
    targetPort: 6379
    protocol: TCP
  selector:
      app: cache-store
---
# Source: ccs/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: ccs-postgres
  labels:
    app: ccs-postgres
spec:
  type: ClusterIP
  selector:
    app: ccs-postgres
  ports:
    - protocol: TCP
      port: 5432
      targetPort: 5432
---
# Source: ccs/charts/adminServices/templates/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: admin-portal
  namespace: ccs
  labels:
    app: admin-portal
spec:
  replicas: 1
  selector:
    matchLabels:
      app: admin-portal
  template:
    metadata:
      labels:
        app: admin-portal
    spec:
      dnsPolicy: ClusterFirst
      nodeSelector:
        {}
      containers:
      - name: admin-portal
        image: coredgeio/ccp_admin_console:latest
        imagePullPolicy: Always
        resources:
          limits:
            cpu: 400m
          requests:
            cpu: 100m
            memory: 200Mi
        ports:
        - name: http
          containerPort: 80
          protocol: TCP
        env:
          - name: VITE_API_URL
            value: ''
          - name: VITE_OIDC_ENABLED
            value: 'true'
          - name: VITE_OIDC_AUTH_URL 
            value: http://127.0.0.132701/auth
          - name: VITE_OIDC_REALM 
            value: 
          - name: VITE_OIDC_CLIENT_ID
            value: "controller"
          - name: VITE_RESOURCE_MONITORING_URL
            value: ""
          - name: VITE_RESOURCE_MANAGEMENT_URL
            value: ""
          - name: VITE_PROJECT_RESOURCE_MONITORING_URL
            value: ""
          - name: VITE_BUILD_VERSION
            value: "latest"
          - name: VITE_INCLUDE_SERVICES
            value: ""
        volumeMounts:
        - name: portal-rev-proxy
          readOnly: true
          mountPath: /etc/nginx/conf.d/default.conf
          subPath: default.conf
      volumes:
      - name: portal-rev-proxy
        configMap:
          name: admin-portal-nginx-conf
---
# Source: ccs/charts/adminServices/templates/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: admin-platform
  namespace: ccs
  labels:
    app: admin-platform
spec:
  replicas: 1
  selector:
    matchLabels:
      app: admin-platform
  template:
    metadata:
      labels:
        app: admin-platform
    spec:
      dnsPolicy: ClusterFirst
      nodeSelector:
        {}
      initContainers:
      - name: postgres-startup
        image: postgres:15
        imagePullPolicy: IfNotPresent
        command:
        - sh
        - -c
        - |
          until pg_isready -h $POSTGRES_HOST -p $POSTGRES_PORT -U $POSTGRES_USER
          do
            echo "Waiting for postgres..."
            sleep 1;
          done
        env:
        - name: POSTGRES_HOST
          valueFrom:
            secretKeyRef:
              name: ccs-postgres-config
              key: DB_HOST
        - name: POSTGRES_USER
          valueFrom:
            secretKeyRef:
              name: ccs-postgres-config
              key: POSTGRES_USER
        - name: POSTGRES_PORT
          valueFrom:
            secretKeyRef:
              name: ccs-postgres-config
              key: DB_PORT
      containers:
      - name: admin-platform
        image: coredgeio/ccp_admin_platform:latest
        imagePullPolicy: Always
        resources:
          limits:
            cpu: 500m
          requests:
            cpu: 100m
            memory: 200Mi
        ports:
        - name: http
          containerPort: 5000
          protocol: TCP
        envFrom:
        - configMapRef:
            name: platform-api-config   
        - configMapRef:
            name: redis-config
        - secretRef:
            name: ccs-postgres-config
        - secretRef:
            name: ccs-auditdb-config
        env:
        - name: POSTGRES_DB
          value: "cloud"
        - name: FLASK_CONFIG
          value: "production"
        - name: AUTH_GATEWAY_ENABLED
          value: "true"
        - name: ALLOWED_ADMIN_USER_DOMAIN
          value: ""
---
# Source: ccs/charts/adminServices/templates/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: admin-platform-celery
  namespace: ccs
  labels:
    app: admin-platform-celery
spec:
  replicas: 1
  selector:
    matchLabels:
      app: admin-platform-celery
  template:
    metadata:
      labels:
        app: admin-platform-celery
    spec:
      dnsPolicy: ClusterFirst
      nodeSelector:
        {}
      initContainers:
      - name: postgres-startup
        image: postgres:15
        imagePullPolicy: IfNotPresent
        command:
        - sh
        - -c
        - |
          until pg_isready -h $POSTGRES_HOST -p $POSTGRES_PORT -U $POSTGRES_USER
          do
            echo "Waiting for postgres..."
            sleep 1;
          done
        env:
        - name: POSTGRES_HOST
          valueFrom:
            secretKeyRef:
              name: ccs-postgres-config
              key: DB_HOST
        - name: POSTGRES_USER
          valueFrom:
            secretKeyRef:
              name: ccs-postgres-config
              key: POSTGRES_USER
        - name: POSTGRES_PORT
          valueFrom:
            secretKeyRef:
              name: ccs-postgres-config
              key: DB_PORT
      containers:
      - name: admin-platform-celery
        image: coredgeio/ccp_admin_platform:latest
        imagePullPolicy: Always              
        command:
          - "/bin/sh"
          - "-c"
          - "celery -A app.celery worker --loglevel=INFO -B"
        resources:
          limits:
            cpu: 1000m
            memory: 6Gi
          requests:
            cpu: 100m
            memory: 2Gi
        ports:
        - name: http
          containerPort: 5000
          protocol: TCP
        envFrom:
        - configMapRef:
            name: platform-api-config   
        - configMapRef:
            name: redis-config
        - secretRef:
            name: ccs-postgres-config
        - secretRef:
            name: ccs-auditdb-config
        env:
        - name: POSTGRES_DB
          value: "cloud"
        - name: FLASK_CONFIG
          value: "production"
        - name: AUTH_GATEWAY_ENABLED
          value: "true"
        - name: ALLOWED_ADMIN_USER_DOMAIN
          value: ""
---
# Source: ccs/charts/auth-service/templates/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: orbiter-auth
  namespace: ccs
spec:
  replicas: 1
  selector:
    matchLabels:
      orbiter.coredge.io: auth
  template:
    metadata:
      labels:
        orbiter.coredge.io: auth
      annotations:
        prometheus.io/path: metrics
        prometheus.io/port: "9100"
        prometheus.io/scrape: "true"
    spec:
      initContainers:
      - name: mongodb-wait-configdb
        image: coredgeio/mongo:5.0.3
        imagePullPolicy: IfNotPresent
        command:
        - /bin/bash
        - -c
        - |
          while true; do
            mongosh --host $MONGODB_SERVICE_SERVICE_HOST -u $MONGO_INITDB_ROOT_USERNAME -p $MONGO_INITDB_ROOT_PASSWORD --eval "rs.status()"
            if [ $? == "0" ]; then
              exit 0
            fi
            echo "waiting for mongodb to start"
            sleep 5
          done
        env:
        - name: MONGO_INITDB_ROOT_USERNAME
          valueFrom:
            secretKeyRef:
              name: configdb-secret
              key: username
        - name: MONGO_INITDB_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: configdb-secret
              key: password
        - name: MONGODB_SERVICE_SERVICE_HOST
          value: "compass-configdb"
      - name: mongodb-wait-metricsdb
        image: coredgeio/mongo:5.0.3
        imagePullPolicy: IfNotPresent
        command:
        - /bin/bash
        - -c
        - |
          while true; do
            mongosh --host $MONGODB_SERVICE_SERVICE_HOST -u $MONGO_INITDB_ROOT_USERNAME -p $MONGO_INITDB_ROOT_PASSWORD --eval "rs.status()"
            if [ $? == "0" ]; then
              exit 0
            fi
            echo "waiting for mongodb to start"
            sleep 5
          done
        env:
        - name: MONGO_INITDB_ROOT_USERNAME
          valueFrom:
            secretKeyRef:
              name: configdb-secret
              key: username
        - name: MONGO_INITDB_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: configdb-secret
              key: password
        - name: MONGODB_SERVICE_SERVICE_HOST
          value: "compass-metricsdb"
      containers:
      - name: auth
        image: coredgeio/orbiter-auth:latest
        imagePullPolicy: IfNotPresent
        ports:
        - containerPort: 8080
        volumeMounts:
        - name: config-vol
          mountPath: /opt/config.yml
          subPath: config.yml
        - name: gateway-config-vol
          mountPath: /opt/gateway.yml
          subPath: config.yml
        - name: keycloak-secret-vol
          mountPath: /opt/keycloak.yml
          subPath: keycloak.yml
        env:
        - name: KEYCLOAK_USER
          valueFrom:
            secretKeyRef:
              name: keycloak-admin-creds
              key: username
        - name: KEYCLOAK_PASSWORD
          valueFrom:
            secretKeyRef:
              name: keycloak-admin-creds
              key: password
        - name: MONGO_DB_USERNAME
          valueFrom:
            secretKeyRef:
              name: configdb-secret
              key: username
        - name: MONGO_DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: configdb-secret
              key: password
        - name: LOCAL_KEYCLOAK_URL
          value: https://keycloak:8443
        - name: ACCESS_LOG_VERBOSE
          value: "true"
        - name: COMPASS_JWT_ISSUER_SECRET
          valueFrom:
            secretKeyRef:
              name: jwt-secret
              key: secretKey
      volumes:
      - name: config-vol
        configMap:
          name: orbiter-auth-config
      - name: gateway-config-vol
        configMap:
          name: gateway-config
      - name: keycloak-secret-vol
        secret:
          secretName: keycloak-secret
---
# Source: ccs/charts/autoscalingService/templates/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: autoscaling-service
  namespace: ccs
  labels:
    app: autoscaling-service
spec:
  replicas: 1
  selector:
    matchLabels:
      app: autoscaling-service
  template:
    metadata: 
      labels:
        app: autoscaling-service
    spec:
      dnsPolicy: ClusterFirst
      nodeSelector:
        {}
      initContainers:
      - name: postgres-startup
        image: postgres:15
        imagePullPolicy: IfNotPresent
        command:
        - sh
        - -c
        - |
          until pg_isready -h $POSTGRES_HOST -p $POSTGRES_PORT -U $POSTGRES_USER
          do
            echo "Waiting for postgres..."
            sleep 1;
          done
        env:
        - name: POSTGRES_HOST
          valueFrom:
            secretKeyRef:
              name: ccs-postgres-config
              key: DB_HOST
        - name: POSTGRES_USER
          valueFrom:
            secretKeyRef:
              name: ccs-postgres-config
              key: POSTGRES_USER
        - name: POSTGRES_PORT
          valueFrom:
            secretKeyRef:
              name: ccs-postgres-config
              key: DB_PORT
      containers:
      - name: autoscaling
        image: coredgeio/ccp_platform:latest
        imagePullPolicy: Always 
        resources:
          limits:
            cpu: 400m
          requests:
            cpu: 100m
            memory: 200Mi
        ports:
        - name: http
          containerPort: 5000
          protocol: TCP
        envFrom:
        - configMapRef:
            name: platform-api-config   
        - configMapRef:
            name: ccp-monitoring-config
        - configMapRef:
            name: redis-config
        - secretRef:
            name: ccs-postgres-config
        - secretRef:
            name: ccs-auditdb-config
        env:
          - name: ENABLED_MODULES
            value: "autoscaling_group,api"     
          - name: POSTGRES_DB
            value: "cloud"
          - name: FLASK_CONFIG
            value: production
          - name: CACHING_ENABLED
            value: "false"
        volumeMounts:
          - name: platform-config
            readOnly: true
            mountPath: /etc/yntraa/
      volumes:
        - name: platform-config
          projected:
            sources:
            - secret:
                name: ccs-super-admin-config
---
# Source: ccs/charts/autoscalingService/templates/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: autoscaling-service-celery
  namespace: ccs
  labels:
    app: autoscaling-service-celery
spec:
  replicas: 1
  selector:
    matchLabels:
      app: autoscaling-service-celery
  template:
    metadata: 
      labels:
        app: autoscaling-service-celery
    spec:
      dnsPolicy: ClusterFirst
      nodeSelector:
        {}
      initContainers:
      - name: postgres-startup
        image: postgres:15
        imagePullPolicy: IfNotPresent
        command:
        - sh
        - -c
        - |
          until pg_isready -h $POSTGRES_HOST -p $POSTGRES_PORT -U $POSTGRES_USER
          do
            echo "Waiting for postgres..."
            sleep 1;
          done
        env:
        - name: POSTGRES_HOST
          valueFrom:
            secretKeyRef:
              name: ccs-postgres-config
              key: DB_HOST
        - name: POSTGRES_USER
          valueFrom:
            secretKeyRef:
              name: ccs-postgres-config
              key: POSTGRES_USER
        - name: POSTGRES_PORT
          valueFrom:
            secretKeyRef:
              name: ccs-postgres-config
              key: DB_PORT
      containers:
      - name: autoscaling-celery
        image: coredgeio/ccp_platform:latest
        imagePullPolicy: Always              
        command:
          - "/bin/sh"
          - "-c"
          - "celery -A app  worker --concurrency=2 --loglevel=debug -Q q_autoscaling_group"
        resources:
          limits:
            cpu: 1000m
            memory: 6Gi
          requests:
            cpu: 100m
            memory: 2Gi
        ports:
        - name: http
          containerPort: 5000
          protocol: TCP
        envFrom:
        - configMapRef:
            name: ccp-monitoring-config
        - configMapRef:
            name: platform-api-config   
        - configMapRef:
            name: redis-config
        - secretRef:
            name: ccs-postgres-config
        - secretRef:
            name: ccs-auditdb-config
        env:
          - name: ENABLED_MODULES
            value: "autoscaling_group,api"     
          - name: POSTGRES_DB
            value: "cloud"
          - name: FLASK_CONFIG
            value: production
          - name: CACHING_ENABLED
            value: "false"
---
# Source: ccs/charts/cloud-manager/templates/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: cloud-manager
  namespace: ccs
spec:
  replicas: 1
  selector:
    matchLabels:
      app: cloud-manager
  template:
    metadata:
      labels:
        app: cloud-manager
    spec:
      serviceAccountName: compass-controller
      initContainers:
      - name: mongodb-wait
        image: coredgeio/mongo:5.0.3
        imagePullPolicy: IfNotPresent
        command:
        - /bin/bash
        - -c
        - |
          while true; do
            mongosh --host $MONGODB_SERVICE_SERVICE_HOST -u $MONGO_INITDB_ROOT_USERNAME -p $MONGO_INITDB_ROOT_PASSWORD --eval "rs.status()"
            if [ $? == "0" ]; then
              exit 0
            fi
            echo "waiting for mongodb to start"
            sleep 5
          done
        env:
        - name: MONGO_INITDB_ROOT_USERNAME
          valueFrom:
            secretKeyRef:
              name: configdb-secret
              key: username
        - name: MONGO_INITDB_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: configdb-secret
              key: password
        - name: MONGODB_SERVICE_SERVICE_HOST
          value: "compass-configdb"
      containers:
      - name: cloud-manager
        image: coredgeio/compass-cloud-manager:latest
        imagePullPolicy: IfNotPresent
        ports:
        - containerPort: 8090
          name: grpc
          protocol: TCP
        env:
        - name: MONGO_DB_USERNAME
          valueFrom:
            secretKeyRef:
              name: configdb-secret
              key: username
        - name: MONGO_DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: configdb-secret
              key: password
        volumeMounts:
        - name: cloud-config-vol
          mountPath: /opt/config.yml
          subPath: config.yml
      imagePullSecrets:
      - name: ccs-docker-registry-key
      dnsPolicy: ClusterFirst
      volumes:
      - name: cloud-config-vol
        configMap:
          name: cloud-manager-config
---
# Source: ccs/charts/computeService/templates/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: compute-service
  namespace: ccs
  labels:
    app: compute-service
spec:
  replicas: 1
  selector:
    matchLabels:
      app: compute-service
  template:
    metadata: 
      labels:
        app: compute-service
    spec:
      dnsPolicy: ClusterFirst
      nodeSelector:
        {}
      initContainers:
      - name: postgres-startup
        image: postgres:15
        imagePullPolicy: IfNotPresent
        command:
        - sh
        - -c
        - |
          until pg_isready -h $POSTGRES_HOST -p $POSTGRES_PORT -U $POSTGRES_USER
          do
            echo "Waiting for postgres..."
            sleep 1;
          done
        env:
        - name: POSTGRES_HOST
          valueFrom:
            secretKeyRef:
              name: ccs-postgres-config
              key: DB_HOST
        - name: POSTGRES_USER
          valueFrom:
            secretKeyRef:
              name: ccs-postgres-config
              key: POSTGRES_USER
        - name: POSTGRES_PORT
          valueFrom:
            secretKeyRef:
              name: ccs-postgres-config
              key: DB_PORT
      containers:
      - name: compute  
        image: coredgeio/ccp_platform:latest
        imagePullPolicy: Always
        resources:
          limits:
            cpu: 400m
          requests:
            cpu: 100m
            memory: 200Mi
        ports:
        - name: http
          containerPort: 5000
          protocol: TCP
        envFrom:
        - configMapRef:
            name: platform-api-config   
        # - configMapRef:
        #     name: ccp-monitoring-config
        - configMapRef:
            name: redis-config
        - secretRef:
            name: ccs-postgres-config
        - secretRef:
            name: ccs-auditdb-config
        env:
          - name: ENABLED_MODULES
            value: "compute,resource_metrices,api"     
          - name: POSTGRES_DB
            value: "cloud"
          - name: FLASK_CONFIG
            value: production
          - name: CACHING_ENABLED
            value: "false"
        volumeMounts:
          - name: platform-config
            readOnly: true
            mountPath: /etc/yntraa/
      volumes:
        - name: platform-config
          projected:
            sources:
            - secret:
                name: ccs-super-admin-config
---
# Source: ccs/charts/computeService/templates/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: compute-service-celery
  namespace: ccs
  labels:
    app: compute-service-celery
spec:
  replicas: 1
  selector:
    matchLabels:
      app: compute-service-celery
  template:
    metadata: 
      labels:
        app: compute-service-celery
    spec:
      dnsPolicy: ClusterFirst
      nodeSelector:
        {}
      initContainers:
      - name: postgres-startup
        image: postgres:15
        imagePullPolicy: IfNotPresent
        command:
        - sh
        - -c
        - |
          until pg_isready -h $POSTGRES_HOST -p $POSTGRES_PORT -U $POSTGRES_USER
          do
            echo "Waiting for postgres..."
            sleep 1;
          done
        env:
        - name: POSTGRES_HOST
          valueFrom:
            secretKeyRef:
              name: ccs-postgres-config
              key: DB_HOST
        - name: POSTGRES_USER
          valueFrom:
            secretKeyRef:
              name: ccs-postgres-config
              key: POSTGRES_USER
        - name: POSTGRES_PORT
          valueFrom:
            secretKeyRef:
              name: ccs-postgres-config
              key: DB_PORT
      containers:
      - name: compute-celery
        image: coredgeio/ccp_platform:latest
        imagePullPolicy: Always              
        command:
          - "/bin/sh"
          - "-c"
          - "celery -A app  worker --concurrency=2 --loglevel=debug -Q q_compute"
        resources:
          limits:
            cpu: 1000m
            memory: 6Gi
          requests:
            cpu: 100m
            memory: 2Gi
        ports:
        - name: http
          containerPort: 5000
          protocol: TCP
        envFrom:
        - configMapRef:
            name: platform-api-config   
        # - configMapRef:
        #     name: ccp-monitoring-config
        - configMapRef:
            name: redis-config
        - secretRef:
            name: ccs-postgres-config
        - secretRef:
            name: ccs-auditdb-config
        env:
          - name: ENABLED_MODULES
            value: "compute,resource_metrices,api"     
          - name: POSTGRES_DB
            value: "cloud"
          - name: FLASK_CONFIG
            value: production
          - name: CACHING_ENABLED
            value: "false"
          - name: CONSOLE_PROXY
            value:
---
# Source: ccs/charts/coremgmtService/templates/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: core-mgmt
  namespace: ccs
  labels:
    app: core-mgmt
spec:
  replicas: 1
  selector:
    matchLabels:
      app: core-mgmt
  template:
    metadata: 
      labels:
        app: core-mgmt
    spec:
      dnsPolicy: ClusterFirst
      nodeSelector:
        {}
      initContainers:
      - name: postgres-startup
        image: postgres:15
        imagePullPolicy: IfNotPresent
        command:
        - sh
        - -c
        - |
          until pg_isready -h $POSTGRES_HOST -p $POSTGRES_PORT -U $POSTGRES_USER
          do
            echo "Waiting for postgres..."
            sleep 1;
          done
        env:
        - name: POSTGRES_HOST
          valueFrom:
            secretKeyRef:
              name: ccs-postgres-config
              key: DB_HOST
        - name: POSTGRES_USER
          valueFrom:
            secretKeyRef:
              name: ccs-postgres-config
              key: POSTGRES_USER
        - name: POSTGRES_PORT
          valueFrom:
            secretKeyRef:
              name: ccs-postgres-config
              key: DB_PORT
      containers:
      - name: core-mgmt  
        image: coredgeio/ccp_platform:latest
        imagePullPolicy: Always
        resources:
          limits:
            cpu: 400m
          requests:
            cpu: 100m
            memory: 200Mi
        ports:
        - name: http
          containerPort: 5000
          protocol: TCP
        envFrom:
        - configMapRef:
            name: platform-api-config   
        - configMapRef:
            name: redis-config
        - secretRef:
            name: ccs-postgres-config
        - secretRef:
            name: ccs-auditdb-config
        env:
          - name: ENABLED_MODULES
            value: "core_mgmt,tickets,api"     
          - name: POSTGRES_DB
            value: "cloud"
          - name: FLASK_CONFIG
            value: production
          - name: CACHING_ENABLED
            value: "false"
        volumeMounts:
          - name: platform-config
            readOnly: true
            mountPath: /etc/yntraa/
      volumes:
        - name: platform-config
          projected:
            sources:
            - secret:
                name: ccs-super-admin-config
---
# Source: ccs/charts/coremgmtService/templates/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: core-mgmt-celery
  namespace: ccs
  labels:
    app: core-mgmt-celery
spec:
  replicas: 1
  selector:
    matchLabels:
      app: core-mgmt-celery
  template:
    metadata: 
      labels:
        app: core-mgmt-celery
    spec:
      dnsPolicy: ClusterFirst
      nodeSelector:
        {}
      initContainers:
      - name: postgres-startup
        image: postgres:15
        imagePullPolicy: IfNotPresent
        command:
        - sh
        - -c
        - |
          until pg_isready -h $POSTGRES_HOST -p $POSTGRES_PORT -U $POSTGRES_USER
          do
            echo "Waiting for postgres..."
            sleep 1;
          done
        env:
        - name: POSTGRES_HOST
          valueFrom:
            secretKeyRef:
              name: ccs-postgres-config
              key: DB_HOST
        - name: POSTGRES_USER
          valueFrom:
            secretKeyRef:
              name: ccs-postgres-config
              key: POSTGRES_USER
        - name: POSTGRES_PORT
          valueFrom:
            secretKeyRef:
              name: ccs-postgres-config
              key: DB_PORT
      containers:
      - name: core-mgmt-celery
        image: coredgeio/ccp_platform:latest
        imagePullPolicy: Always              
        command:
          - "/bin/sh"
          - "-c"
          - "celery -A app  worker --concurrency=2 --loglevel=debug"
        resources:
          limits:
            cpu: 1000m
            memory: 6Gi
          requests:
            cpu: 100m
            memory: 2Gi
        ports:
        - name: http
          containerPort: 5000
          protocol: TCP
        envFrom:
        - configMapRef:
            name: platform-api-config
        - configMapRef:
            name: redis-config
        - secretRef:
            name: ccs-postgres-config
        - secretRef:
            name: ccs-auditdb-config
        env:
          - name: ENABLED_MODULES
            value: "core_mgmt,tickets,api"     
          - name: POSTGRES_DB
            value: "cloud"
          - name: FLASK_CONFIG
            value: production
          - name: CACHING_ENABLED
            value: "false"
---
# Source: ccs/charts/grafana/templates/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ccs-grafana
  namespace: ccs
  labels:
    helm.sh/chart: grafana-6.52.1
    app.kubernetes.io/name: grafana
    app.kubernetes.io/instance: ccs
    app.kubernetes.io/version: "9.4.3"
    app.kubernetes.io/managed-by: Helm
spec:
  replicas: 1
  revisionHistoryLimit: 10
  selector:
    matchLabels:
      app.kubernetes.io/name: grafana
      app.kubernetes.io/instance: ccs
  strategy:
    type: RollingUpdate
  template:
    metadata:
      labels:
        app.kubernetes.io/name: grafana
        app.kubernetes.io/instance: ccs
      annotations:
        checksum/config: 247d99c67758d0f1367f57e0cd71b907fe699bb6830d4bc9b847ba925c94453d
        checksum/dashboards-json-config: 01ba4719c80b6fe911b091a7c05124b64eeece964e09c058ef8f9805daca546b
        checksum/sc-dashboard-provider-config: 01ba4719c80b6fe911b091a7c05124b64eeece964e09c058ef8f9805daca546b
        checksum/secret: 844849d4c15355e404f565c677de8c96ab5356adf63a9a7d11bf5801e903098b
    spec:
      
      serviceAccountName: ccs-grafana
      automountServiceAccountToken: true
      securityContext:
        fsGroup: 472
        runAsGroup: 472
        runAsUser: 472
      initContainers:
        - name: init-chown-data
          image: "busybox:1.31.1"
          imagePullPolicy: IfNotPresent
          securityContext:
            runAsNonRoot: false
            runAsUser: 0
          command:
            - chown
            - -R
            - 472:472
            - /var/lib/grafana
          volumeMounts:
            - name: storage
              mountPath: "/var/lib/grafana"
      enableServiceLinks: true
      containers:
        - name: grafana
          image: "grafana/grafana:9.4.3"
          imagePullPolicy: IfNotPresent
          volumeMounts:
            - name: config
              mountPath: "/etc/grafana/grafana.ini"
              subPath: grafana.ini
            - name: storage
              mountPath: "/var/lib/grafana"
          ports:
            - name: grafana
              containerPort: 3000
              protocol: TCP
            - name: gossip-tcp
              containerPort: 9094
              protocol: TCP
            - name: gossip-udp
              containerPort: 9094
              protocol: UDP
          env:
            - name: POD_IP
              valueFrom:
                fieldRef:
                  fieldPath: status.podIP
            - name: GF_SECURITY_ADMIN_USER
              valueFrom:
                secretKeyRef:
                  name: ccs-grafana
                  key: admin-user
            - name: GF_SECURITY_ADMIN_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: ccs-grafana
                  key: admin-password
            - name: GF_PATHS_DATA
              value: /var/lib/grafana/
            - name: GF_PATHS_LOGS
              value: /var/log/grafana
            - name: GF_PATHS_PLUGINS
              value: /var/lib/grafana/plugins
            - name: GF_PATHS_PROVISIONING
              value: /etc/grafana/provisioning
          livenessProbe:
            failureThreshold: 10
            httpGet:
              path: /api/health
              port: 3000
            initialDelaySeconds: 60
            timeoutSeconds: 30
          readinessProbe:
            httpGet:
              path: /api/health
              port: 3000
      volumes:
        - name: config
          configMap:
            name: ccs-grafana
        - name: storage
          persistentVolumeClaim:
            claimName: ccs-grafana
---
# Source: ccs/charts/metering/templates/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: orbiter-metering
  namespace: ccs
spec:
  replicas: 1
  selector:
    matchLabels:
      app: orbiter-metering
  template:
    metadata:
      labels:
        app: orbiter-metering
    spec:
      serviceAccountName: compass-controller
      initContainers:
      - name: mongodb-wait
        image: coredgeio/mongo:5.0.3
        imagePullPolicy: IfNotPresent
        command:
        - /bin/bash
        - -c
        - |
          while true; do
            mongosh --host $MONGODB_SERVICE_SERVICE_HOST -u $MONGO_INITDB_ROOT_USERNAME -p $MONGO_INITDB_ROOT_PASSWORD --eval "rs.status()"
            if [ $? == "0" ]; then
              exit 0
            fi
            echo "waiting for mongodb to start"
            sleep 5
          done
        env:
        - name: MONGO_INITDB_ROOT_USERNAME
          valueFrom:
            secretKeyRef:
              name: configdb-secret
              key: username
        - name: MONGO_INITDB_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: configdb-secret
              key: password
        - name: MONGODB_SERVICE_SERVICE_HOST
          value: "compass-configdb"
      containers:
      - name: orbiter-metering
        image: coredgeio/orbiter-metering:latest
        imagePullPolicy: IfNotPresent
        ports:
        - containerPort: 8090
          name: grpc
          protocol: TCP
        env:
        - name: MONGO_DB_USERNAME
          valueFrom:
            secretKeyRef:
              name: configdb-secret
              key: username
        - name: MONGO_DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: configdb-secret
              key: password
        volumeMounts:
        - name: metering-config-vol
          mountPath: /opt/config.yml
          subPath: config.yml
      imagePullSecrets:
      - name: ccs-docker-registry-key
      dnsPolicy: ClusterFirst
      volumes:
      - name: metering-config-vol
        configMap:
          name: orbiter-metering-config
---
# Source: ccs/charts/neutronService/templates/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: neutron-service
  namespace: ccs
  labels:
    app: neutron-service
spec:
  replicas: 1
  selector:
    matchLabels:
      app: neutron-service
  template:
    metadata: 
      labels:
        app: neutron-service
    spec:
      dnsPolicy: ClusterFirst
      nodeSelector:
        {}
      initContainers:
      - name: postgres-startup
        image: postgres:15
        imagePullPolicy: IfNotPresent
        command:
        - sh
        - -c
        - |
          until pg_isready -h $POSTGRES_HOST -p $POSTGRES_PORT -U $POSTGRES_USER
          do
            echo "Waiting for postgres..."
            sleep 1;
          done
        env:
        - name: POSTGRES_HOST
          valueFrom:
            secretKeyRef:
              name: ccs-postgres-config
              key: DB_HOST
        - name: POSTGRES_USER
          valueFrom:
            secretKeyRef:
              name: ccs-postgres-config
              key: POSTGRES_USER
        - name: POSTGRES_PORT
          valueFrom:
            secretKeyRef:
              name: ccs-postgres-config
              key: DB_PORT
      containers:
      - name: network
        image: coredgeio/ccp_platform:latest
        imagePullPolicy: Always
        resources:
          limits:
            cpu: 400m
          requests:
            cpu: 100m
            memory: 200Mi
        ports:
        - name: http
          containerPort: 5000
          protocol: TCP
        envFrom:
        - configMapRef:
            name: platform-api-config   
        - configMapRef:
            name: redis-config
        - secretRef:
            name: ccs-postgres-config
        - secretRef:
            name: ccs-auditdb-config
        env:
          - name: ENABLED_MODULES
            value: "networks,dns,certificates,api"     
          - name: POSTGRES_DB
            value: "cloud"
          - name: FLASK_CONFIG
            value: production
          - name: CACHING_ENABLED
            value: "false"
        volumeMounts:
          - name: provider-vol
            readOnly: true
            mountPath: /etc/yntraa/
          - name: api-conf-vol
            mountPath: /etc/api/
          - name: openstack-templates-vol
            mountPath: /etc/yntraa/app/extensions/providers/templates/openstack/
          - name: openstack-templates-lib-vol
            mountPath: /etc/yntraa/app/extensions/providers/templates/openstack/lib/
      volumeMounts:
          - name: platform-config
            readOnly: true
            mountPath: /etc/yntraa/
      volumes:
        - name: platform-config
          projected:
            sources:
            - secret:
                name: ccs-super-admin-config
---
# Source: ccs/charts/neutronService/templates/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: neutron-service-celery
  namespace: ccs
  labels:
    app: neutron-service-celery
spec:
  replicas: 1
  selector:
    matchLabels:
      app: neutron-service-celery
  template:
    metadata: 
      labels:
        app: neutron-service-celery
    spec:
      dnsPolicy: ClusterFirst
      nodeSelector:
        {}
      initContainers:
      - name: postgres-startup
        image: postgres:15
        imagePullPolicy: IfNotPresent
        command:
        - sh
        - -c
        - |
          until pg_isready -h $POSTGRES_HOST -p $POSTGRES_PORT -U $POSTGRES_USER
          do
            echo "Waiting for postgres..."
            sleep 1;
          done
        env:
        - name: POSTGRES_HOST
          valueFrom:
            secretKeyRef:
              name: ccs-postgres-config
              key: DB_HOST
        - name: POSTGRES_USER
          valueFrom:
            secretKeyRef:
              name: ccs-postgres-config
              key: POSTGRES_USER
        - name: POSTGRES_PORT
          valueFrom:
            secretKeyRef:
              name: ccs-postgres-config
              key: DB_PORT
      containers:
      - name: network-celery
        image: coredgeio/ccp_platform:latest
        imagePullPolicy: Always              
        command:
          - "/bin/sh"
          - "-c"
          - "celery -A app  worker --concurrency=2 --loglevel=debug -Q q_network"
        resources:
          limits:
            cpu: 1000m
            memory: 6Gi
          requests:
            cpu: 100m
            memory: 2Gi
        ports:
        - name: http
          containerPort: 5000
          protocol: TCP
        envFrom:
        - configMapRef:
            name: platform-api-config  
        - configMapRef:
            name: redis-config
        - secretRef:
            name: ccs-postgres-config
        - secretRef:
            name: ccs-auditdb-config
        env:
          - name: ENABLED_MODULES
            value: "networks,dns,certificates,api"     
          - name: POSTGRES_DB
            value: "cloud"
          - name: FLASK_CONFIG
            value: production
          - name: CACHING_ENABLED
            value: "false"
---
# Source: ccs/charts/postgres-operator/templates/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app.kubernetes.io/name: postgres-operator
    helm.sh/chart: postgres-operator-1.12.2
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/instance: ccs
  name: ccs-postgres-operator
  namespace: ccs
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: postgres-operator
      app.kubernetes.io/instance: ccs
  template:
    metadata:
      annotations:
        checksum/config: eb559bf453a3f438c453d52ac07e9638b2b8762287b6d2d42f0a5504a852a280
      labels:
        app.kubernetes.io/name: postgres-operator
        app.kubernetes.io/instance: ccs
    spec:
      serviceAccountName: postgresql-operator
      containers:
      - name: postgres-operator
        image: "docker.io/coredgeio/postgres-operator:v1.12.2"
        imagePullPolicy: IfNotPresent
        env:
        - name: POSTGRES_OPERATOR_CONFIGURATION_OBJECT
          value: ccs-postgres-operator
        resources:
          limits:
            cpu: 400m
            memory: 500Mi
          requests:
            cpu: 100m
            memory: 250Mi
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          runAsNonRoot: true
          runAsUser: 1000
        readinessProbe:
          httpGet:
            path: /readyz
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 10
      affinity:
        {}
      nodeSelector:
        {}
      tolerations:
        []
---
# Source: ccs/charts/userPortal/templates/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: user-portal
  namespace: ccs
  labels:
    app: user-portal
spec:
  replicas: 1
  selector:
    matchLabels:
      app: user-portal
  template:
    metadata:
      labels:
        app: user-portal
    spec:
      dnsPolicy: ClusterFirst
      nodeSelector:
        {}
      containers:
      - name: user-portal
        image: coredgeio/ccp_console:latest
        imagePullPolicy: Always
        resources:
          limits:
            cpu: 400m
          requests:
            cpu: 100m
            memory: 200Mi
        ports:
        - name: http
          containerPort: 80
          protocol: TCP
        env:
          - name: VITE_OIDC_ENABLED 
            value: 'true'
          - name: VITE_OIDC_AUTH_URL 
            value: http://127.0.0.132701/auth
          - name: VITE_OIDC_REALM 
            value: 
          - name: VITE_OIDC_CLIENT_ID
            value: "controller"
          - name: VITE_API_URL
            value: ''          
          - name: VITE_DOC_URL
            value: ""
          - name: VITE_BUILD_VERSION
            value: "latest"
          - name: VITE_INCLUDE_SERVICES
            value: ""
          - name: VITE_QUARTZ_URL
            value: ""
          - name: VITE_COBALT_URL
            value: ""
          - name: VITE_SHOW_CHATBOT
            value: "false"
          - name: VITE_APP_STORE_URL
            value: ""
          - name: VITE_SECURITY_COMPLIANCE_URL
            value: ""
          - name: VITE_USER_REGISTER_URL
            value: ""
          - name: VITE_PAM_IFRAME_URL
            value: ""
          - name: VITE_VM_CONSOLE_URL
            value: ""
          - name: VITE_CLOUD_SECURITY_POSTURE_URL
            value: ""
          - name: VITE_VIRTUAL_SUITE_DASHBOARD_URL
            value: ""
          - name: VITE_TICKET_SUPPORT_URL
            value: ""
        volumeMounts:
        - name: console-rev-proxy
          readOnly: true
          mountPath: /etc/nginx/conf.d/default.conf
          subPath: default.conf
      volumes:
      - name: console-rev-proxy
        configMap:
          name: console-nginx-conf
---
# Source: ccs/charts/volumeService/templates/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: volume-service
  namespace: ccs
  labels:
    app: volume-service
spec:
  replicas: 1
  selector:
    matchLabels:
      app: volume-service
  template:
    metadata: 
      labels:
        app: volume-service
    spec:
      dnsPolicy: ClusterFirst
      nodeSelector:
        {}
      initContainers:
      - name: postgres-startup
        image: postgres:15
        imagePullPolicy: IfNotPresent
        command:
        - sh
        - -c
        - |
          until pg_isready -h $POSTGRES_HOST -p $POSTGRES_PORT -U $POSTGRES_USER
          do
            echo "Waiting for postgres..."
            sleep 1;
          done
        env:
        - name: POSTGRES_HOST
          valueFrom:
            secretKeyRef:
              name: ccs-postgres-config
              key: DB_HOST
        - name: POSTGRES_USER
          valueFrom:
            secretKeyRef:
              name: ccs-postgres-config
              key: POSTGRES_USER
        - name: POSTGRES_PORT
          valueFrom:
            secretKeyRef:
              name: ccs-postgres-config
              key: DB_PORT
      containers:
      - name: volume  
        image: coredgeio/ccp_platform:latest
        imagePullPolicy: Always
        resources:
          limits:
            cpu: 400m
          requests:
            cpu: 100m
            memory: 200Mi
        ports:
        - name: http
          containerPort: 5000
          protocol: TCP
        envFrom:
        - configMapRef:
            name: platform-api-config   
        - configMapRef:
            name: redis-config
        - secretRef:
            name: ccs-postgres-config
        - secretRef:
            name: ccs-auditdb-config
        env:
          - name: ENABLED_MODULES
            value: "volumes,api"     
          - name: POSTGRES_DB
            value: "cloud"
          - name: FLASK_CONFIG
            value: production
          - name: CACHING_ENABLED
            value: "false"
        volumeMounts:
          - name: platform-config
            readOnly: true
            mountPath: /etc/yntraa/
      volumes:
        - name: platform-config
          projected:
            sources:
            - secret:
                name: ccs-super-admin-config
---
# Source: ccs/charts/volumeService/templates/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: volume-service-celery
  namespace: ccs
  labels:
    app: volume-service-celery
spec:
  replicas: 1
  selector:
    matchLabels:
      app: volume-service-celery
  template:
    metadata: 
      labels:
        app: volume-service-celery
    spec:
      dnsPolicy: ClusterFirst
      nodeSelector:
        {}
      initContainers:
      - name: postgres-startup
        image: postgres:15
        imagePullPolicy: IfNotPresent
        command:
        - sh
        - -c
        - |
          until pg_isready -h $POSTGRES_HOST -p $POSTGRES_PORT -U $POSTGRES_USER
          do
            echo "Waiting for postgres..."
            sleep 1;
          done
        env:
        - name: POSTGRES_HOST
          valueFrom:
            secretKeyRef:
              name: ccs-postgres-config
              key: DB_HOST
        - name: POSTGRES_USER
          valueFrom:
            secretKeyRef:
              name: ccs-postgres-config
              key: POSTGRES_USER
        - name: POSTGRES_PORT
          valueFrom:
            secretKeyRef:
              name: ccs-postgres-config
              key: DB_PORT
      - name: volume-celery
        image: coredgeio/ccp_platform:latest
        imagePullPolicy: Always              
        command:
          - "/bin/sh"
          - "-c"
          - "celery -A app  worker --concurrency=2 --loglevel=debug -Q q_volume"
        resources:
          limits:
            cpu: 1000m
            memory: 6Gi
          requests:
            cpu: 100m
            memory: 2Gi
        ports:
        - name: http
          containerPort: 5000
          protocol: TCP
        envFrom:
        - configMapRef:
            name: platform-api-config   
        - configMapRef:
            name: redis-config
        - secretRef:
            name: ccs-postgres-config
        - secretRef:
            name: ccs-auditdb-config
        env:
          - name: ENABLED_MODULES
            value: "volumes,api"     
          - name: POSTGRES_DB
            value: "cloud"
          - name: FLASK_CONFIG
            value: production
          - name: CACHING_ENABLED
            value: "false"
---
# Source: ccs/templates/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: compass-api
  namespace: ccs
spec:
  replicas: 1
  selector:
    matchLabels:
      app: compass-api
  template:
    metadata:
      labels:
        app: compass-api
      annotations:
        prometheus.io/path: metrics
        prometheus.io/port: "9100"
        prometheus.io/scrape: "true"
    spec:
      serviceAccountName: compass-controller
      initContainers:
      - name: mongodb-wait
        image: coredgeio/mongo:5.0.3
        imagePullPolicy: IfNotPresent
        command:
        - /bin/bash
        - -c
        - |
          while true; do
            mongosh --host $MONGODB_SERVICE_SERVICE_HOST -u $MONGO_INITDB_ROOT_USERNAME -p $MONGO_INITDB_ROOT_PASSWORD --eval "rs.status()"
            if [ $? == "0" ]; then
              exit 0
            fi
            echo "waiting for mongodb to start"
            sleep 5
          done
        env:
        - name: MONGO_INITDB_ROOT_USERNAME
          valueFrom:
            secretKeyRef:
              name: configdb-secret
              key: username
        - name: MONGO_INITDB_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: configdb-secret
              key: password
        - name: MONGODB_SERVICE_SERVICE_HOST
          value: "compass-configdb"
      containers:
      - name: api
        image: coredgeio/compass-api:latest
        imagePullPolicy: IfNotPresent
        ports:
        - containerPort: 8090
          name: grpc
          protocol: TCP
        - containerPort: 9100
          name: metrics
          protocol: TCP
        env:
        - name: MONGO_DB_USERNAME
          valueFrom:
            secretKeyRef:
              name: configdb-secret
              key: username
        - name: MONGO_DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: configdb-secret
              key: password
        - name: KEYCLOAK_USER
          valueFrom:
            secretKeyRef:
              name: keycloak-admin-creds
              key: username
        - name: KEYCLOAK_PASSWORD
          valueFrom:
            secretKeyRef:
              name: keycloak-admin-creds
              key: password
        - name: LOCAL_KEYCLOAK_URL
          value: "https://keycloak:8443"
        - name: COMPASS_JWT_ISSUER_SECRET
          valueFrom:
            secretKeyRef:
              name: jwt-secret
              key: secretKey
        volumeMounts:
        - name: api-config-vol
          mountPath: /opt/config.yml
          subPath: config.yml
        - name: api-config-secret-vol
          mountPath: /opt/keycloak.yml
          subPath: keycloak.yml
        - name: controller-certs-vol
          mountPath: /opt/certs
        - name: trivy-config-vol
          mountPath: /opt/trivy.yml
          subPath: trivy.yml
      imagePullSecrets:
      - name: ccs-docker-registry-key
      dnsPolicy: ClusterFirst
      volumes:
      - name: controller-certs-vol
        secret:
          secretName: controller-certs
      - name: api-config-secret-vol
        secret:
          secretName: api-config-secret
      - name: api-config-vol
        configMap:
          name: api-config
      - name: trivy-config-vol
        configMap:
          name: trivy-config
---
# Source: ccs/templates/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: compass-controller
  namespace: ccs
spec:
  replicas: 1
  selector:
    matchLabels:
      app: compass-controller
  template:
    metadata:
      labels:
        app: compass-controller
    spec:
      serviceAccountName: compass-controller
      initContainers:
      - name: mongodb-wait
        image: coredgeio/mongo:5.0.3
        imagePullPolicy: IfNotPresent
        command:
        - /bin/bash
        - -c
        - |
          while true; do
            mongosh --host $MONGODB_SERVICE_SERVICE_HOST -u $MONGO_INITDB_ROOT_USERNAME -p $MONGO_INITDB_ROOT_PASSWORD --eval "rs.status()"
            if [ $? == "0" ]; then
              exit 0
            fi
            echo "waiting for mongodb to start"
            sleep 5
          done
        env:
        - name: MONGO_INITDB_ROOT_USERNAME
          valueFrom:
            secretKeyRef:
              name: configdb-secret
              key: username
        - name: MONGO_INITDB_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: configdb-secret
              key: password
        - name: MONGODB_SERVICE_SERVICE_HOST
          value: "compass-configdb"
      containers:
      - name: controller
        image: coredgeio/compass-controller:latest
        imagePullPolicy: IfNotPresent
        ports:
        - containerPort: 8080
          name: http
          protocol: TCP
        - containerPort: 8090
          name: grpc
          protocol: TCP
        env:
        - name: MONGO_DB_USERNAME
          valueFrom:
            secretKeyRef:
              name: configdb-secret
              key: username
        - name: MONGO_DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: configdb-secret
              key: password
        volumeMounts:
        - name: controller-certs-vol
          mountPath: /opt/certs
        - name: ingress-certs-vol
          mountPath: /opt/certs/ingress
        - name: controller-config-vol
          mountPath: /opt/
      imagePullSecrets:
      - name: ccs-docker-registry-key
      dnsPolicy: ClusterFirst
      volumes:
      - name: ingress-certs-vol
        secret:
          secretName: ingress-certs
      - name: controller-certs-vol
        secret:
          secretName: controller-certs
      - name: controller-config-vol
        configMap:
          name: controller-config
---
# Source: ccs/templates/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: compass-term
  namespace: ccs
spec:
  replicas: 1
  selector:
    matchLabels:
      app: compass-term
  template:
    metadata:
      labels:
        app: compass-term
    spec:
      serviceAccountName: compass-controller
      initContainers:
      - name: mongodb-wait
        image: coredgeio/mongo:5.0.3
        imagePullPolicy: IfNotPresent
        command:
        - /bin/bash
        - -c
        - |
          while true; do
            mongosh --host $MONGODB_SERVICE_SERVICE_HOST -u $MONGO_INITDB_ROOT_USERNAME -p $MONGO_INITDB_ROOT_PASSWORD --eval "rs.status()"
            if [ $? == "0" ]; then
              exit 0
            fi
            echo "waiting for mongodb to start"
            sleep 5
          done
        env:
        - name: MONGO_INITDB_ROOT_USERNAME
          valueFrom:
            secretKeyRef:
              name: configdb-secret
              key: username
        - name: MONGO_INITDB_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: configdb-secret
              key: password
        - name: MONGODB_SERVICE_SERVICE_HOST
          value: "compass-configdb"
      containers:
      - name: terminal
        image: coredgeio/compass-term:latest
        imagePullPolicy: IfNotPresent
        ports:
        - containerPort: 8000
          name: websocket
          protocol: TCP
        env:
        - name: MONGO_DB_USERNAME
          valueFrom:
            secretKeyRef:
              name: configdb-secret
              key: username
        - name: MONGO_DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: configdb-secret
              key: password
        volumeMounts:
        - name: terminal-config-vol
          mountPath: /opt/
        - name: ingress-certs-vol
          mountPath: /opt/certs/ingress
      imagePullSecrets:
      - name: ccs-docker-registry-key
      dnsPolicy: ClusterFirst
      volumes:
      - name: ingress-certs-vol
        secret:
          secretName: ingress-certs
      - name: terminal-config-vol
        configMap:
          name: terminal-config
---
# Source: ccs/templates/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: kg-cluster-notifier
  namespace: ccs
spec:
  replicas: 1
  selector:
    matchLabels:
      app: kg-cluster-notifier
  template:
    metadata:
      labels:
        app: kg-cluster-notifier
    spec:
      serviceAccountName: compass-controller
      initContainers:
      - name: mongodb-wait
        image: coredgeio/mongo:5.0.3
        imagePullPolicy: IfNotPresent
        command:
        - /bin/bash
        - -c
        - |
          while true; do
            mongosh --host $MONGODB_SERVICE_SERVICE_HOST -u $MONGO_INITDB_ROOT_USERNAME -p $MONGO_INITDB_ROOT_PASSWORD --eval "rs.status()"
            if [ $? == "0" ]; then
              exit 0
            fi
            echo "waiting for mongodb to start"
            sleep 5
          done
        env:
        - name: MONGO_INITDB_ROOT_USERNAME
          valueFrom:
            secretKeyRef:
              name: configdb-secret
              key: username
        - name: MONGO_INITDB_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: configdb-secret
              key: password
        - name: MONGODB_SERVICE_SERVICE_HOST
          value: "compass-configdb"
      containers:
      - name: kg-cluster-notifier
        image: coredgeio/kg-cluster-notifier:latest
        imagePullPolicy: IfNotPresent
        env:
        - name: MONGO_DB_USERNAME
          valueFrom:
            secretKeyRef:
              name: configdb-secret
              key: username
        - name: MONGO_DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: configdb-secret
              key: password
        volumeMounts:
        - name: ingress-certs-vol
          mountPath: /opt/certs/ingress
        - name: kg-config-vol
          mountPath: /opt/
      imagePullSecrets:
      - name: ccs-docker-registry-key
      dnsPolicy: ClusterFirst
      volumes:
      - name: ingress-certs-vol
        secret:
          secretName: ingress-certs
      - name: kg-config-vol
        configMap:
          name: kg-cluster-config
---
# Source: ccs/templates/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: compass-orchestrator
  namespace: ccs
spec:
  # currently we only support 1 replica
  replicas: 1
  selector:
    matchLabels:
      app: compass-orchestrator
  template:
    metadata:
      labels:
        app: compass-orchestrator
    spec:
      serviceAccountName: compass-controller
      initContainers:
      - name: mongodb-wait
        image: coredgeio/mongo:5.0.3
        imagePullPolicy: IfNotPresent
        command:
        - /bin/bash
        - -c
        - |
          while true; do
            mongosh --host $MONGODB_SERVICE_SERVICE_HOST -u $MONGO_INITDB_ROOT_USERNAME -p $MONGO_INITDB_ROOT_PASSWORD --eval "rs.status()"
            if [ $? == "0" ]; then
              exit 0
            fi
            echo "waiting for mongodb to start"
            sleep 5
          done
        env:
        - name: MONGO_INITDB_ROOT_USERNAME
          valueFrom:
            secretKeyRef:
              name: configdb-secret
              key: username
        - name: MONGO_INITDB_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: configdb-secret
              key: password
        - name: MONGODB_SERVICE_SERVICE_HOST
          value: "compass-configdb"
      containers:
      - name: orchestrator
        image: coredgeio/compass-orchestrator:latest
        imagePullPolicy: IfNotPresent
        env:
        - name: MONGO_DB_USERNAME
          valueFrom:
            secretKeyRef:
              key: username
              name: configdb-secret
        - name: MONGO_DB_PASSWORD
          valueFrom:
            secretKeyRef:
              key: password
              name: configdb-secret
        - name: ADDONS_IMAGE_REPO
          value: "coredgeio"
        volumeMounts:
        - mountPath: /opt/
          name: orchestrator-config-vol
        - mountPath: /opt/certs/ingress
          name: ingress-certs-vol
      imagePullSecrets:
      - name: ccs-docker-registry-key
      dnsPolicy: ClusterFirst
      volumes:
      - name: ingress-certs-vol
        secret:
          secretName: ingress-certs
      - name: orchestrator-config-vol
        configMap:
          name: orchestrator-config
---
# Source: ccs/templates/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: compass-metric-server
  namespace: ccs
spec:
  replicas: 1
  selector:
    matchLabels:
      app: compass-metric-server
  template:
    metadata:
      labels:
        app: compass-metric-server
    spec:
      serviceAccountName: compass-controller
      initContainers:
      - name: mongodb-wait
        image: coredgeio/mongo:5.0.3
        imagePullPolicy: IfNotPresent
        command:
        - /bin/bash
        - -c
        - |
          while true; do
            mongosh --host $MONGODB_SERVICE_SERVICE_HOST -u $MONGO_INITDB_ROOT_USERNAME -p $MONGO_INITDB_ROOT_PASSWORD --eval "rs.status()"
            if [ $? == "0" ]; then
              exit 0
            fi
            echo "waiting for mongodb to start"
            sleep 5
          done
        env:
        - name: MONGO_INITDB_ROOT_USERNAME
          valueFrom:
            secretKeyRef:
              name: configdb-secret
              key: username
        - name: MONGO_INITDB_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: configdb-secret
              key: password
        - name: MONGODB_SERVICE_SERVICE_HOST
          value: "compass-configdb"
      - name: metricsdb-wait
        image: coredgeio/mongo:5.0.3
        imagePullPolicy: IfNotPresent
        command:
        - /bin/bash
        - -c
        - |
          while true; do
            mongosh --host $MONGODB_SERVICE_SERVICE_HOST -u $MONGO_INITDB_ROOT_USERNAME -p $MONGO_INITDB_ROOT_PASSWORD --eval "rs.status()"
            if [ $? == "0" ]; then
              exit 0
            fi
            echo "waiting for mongodb to start"
            sleep 5
          done
        env:
        - name: MONGO_INITDB_ROOT_USERNAME
          valueFrom:
            secretKeyRef:
              name: configdb-secret
              key: username
        - name: MONGO_INITDB_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: configdb-secret
              key: password
        - name: MONGODB_SERVICE_SERVICE_HOST
          value: "compass-metricsdb"
      containers:
      - name: metric-server
        image: coredgeio/compass-metric-server:latest
        imagePullPolicy: IfNotPresent
        env:
        - name: MONGO_DB_USERNAME
          valueFrom:
            secretKeyRef:
              key: username
              name: configdb-secret
        - name: MONGO_DB_PASSWORD
          valueFrom:
            secretKeyRef:
              key: password
              name: configdb-secret
        - name: KEYCLOAK_USER
          valueFrom:
            secretKeyRef:
              name: keycloak-admin-creds
              key: username
        - name: KEYCLOAK_PASSWORD
          valueFrom:
            secretKeyRef:
              name: keycloak-admin-creds
              key: password
        volumeMounts:
        - name: metric-server-config-vol
          mountPath: /opt/config.yml
          subPath: config.yml
        - name: metric-server-config-secret-vol
          mountPath: /opt/keycloak.yml
          subPath: keycloak.yml
      imagePullSecrets:
      - name: ccs-docker-registry-key
      dnsPolicy: ClusterFirst
      volumes:
      - name: metric-server-config-vol
        configMap:
          name: metric-server-config
      - name: metric-server-config-secret-vol
        secret:
          secretName: api-config-secret
---
# Source: ccs/templates/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: compass-cluster-manager
  namespace: ccs
spec:
  replicas: 1
  selector:
    matchLabels:
      app: compass-cluster-manager
  template:
    metadata:
      labels:
        app: compass-cluster-manager
    spec:
      serviceAccountName: compass-controller
      initContainers:
      - name: mongodb-wait
        image: coredgeio/mongo:5.0.3
        imagePullPolicy: IfNotPresent
        command:
        - /bin/bash
        - -c
        - |
          while true; do
            mongosh --host $MONGODB_SERVICE_SERVICE_HOST -u $MONGO_INITDB_ROOT_USERNAME -p $MONGO_INITDB_ROOT_PASSWORD --eval "rs.status()"
            if [ $? == "0" ]; then
              exit 0
            fi
            echo "waiting for mongodb to start"
            sleep 5
          done
        env:
        - name: MONGO_INITDB_ROOT_USERNAME
          valueFrom:
            secretKeyRef:
              key: username
              name: configdb-secret
        - name: MONGO_INITDB_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              key: password
              name: configdb-secret
        - name: MONGODB_SERVICE_SERVICE_HOST
          value: compass-configdb
      containers:
      - name: cluster-manager
        image: coredgeio/compass-cluster-manager:latest
        imagePullPolicy: IfNotPresent
        ports:
        - containerPort: 8080
          name: http
          protocol: TCP
        env:
        - name: MONGO_DB_USERNAME
          valueFrom:
            secretKeyRef:
              key: username
              name: configdb-secret
        - name: MONGO_DB_PASSWORD
          valueFrom:
            secretKeyRef:
              key: password
              name: configdb-secret
        - name: KEYCLOAK_USER
          valueFrom:
            secretKeyRef:
              name: keycloak-admin-creds
              key: username
        - name: KEYCLOAK_PASSWORD
          valueFrom:
            secretKeyRef:
              name: keycloak-admin-creds
              key: password
        - name: COMPASS_JWT_ISSUER_SECRET
          valueFrom:
            secretKeyRef:
              name: jwt-secret
              key: secretKey
        volumeMounts:
        - mountPath: /opt/config.yml
          name: api-config-vol
          subPath: config.yml
        - mountPath: /opt/certs
          name: controller-certs-vol
      imagePullSecrets:
      - name: ccs-docker-registry-key
      volumes:
      - name: controller-certs-vol
        secret:
          defaultMode: 420
          secretName: controller-certs
      - configMap:
          defaultMode: 420
          name: api-config
        name: api-config-vol
---
# Source: ccs/templates/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: sockets-server
  namespace: ccs
  labels:
    app: sockets-server
spec:
  replicas: 1
  selector:
    matchLabels:
      app: sockets-server
  template:
    metadata:
      labels:
        app: sockets-server
    spec:
      dnsPolicy: ClusterFirst
      nodeSelector:
      containers:
      - name: socket
        image: coredgeio/socket:latest
        imagePullPolicy: Always
        ports:
        - name: http
          containerPort: 5000
          protocol: TCP
        env:
        - name: REDIS_HOST
          value: cache-store
        - name: REDIS_PORT
          value: "6379"
---
# Source: ccs/charts/keycloak-ha/templates/statefulset.yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: keycloak
  namespace: ccs
  labels:
    app: keycloak
spec:
  replicas: 3
  selector:
    matchLabels:
      app: keycloak
  template:
    metadata:
      labels:
        app: keycloak
    spec:
      dnsPolicy: ClusterFirst
      serviceAccount: keycloak
      serviceAccountName: keycloak
      nodeSelector:
        {}
      affinity:
        {}
      initContainers:
      - name: postgres-startup
        image: postgres:15
        imagePullPolicy: IfNotPresent
        command:
        - sh
        - -c
        - |
          until pg_isready -h $POSTGRES_HOST -p $POSTGRES_PORT -U $POSTGRES_USER
          do
            echo "Waiting for postgres..."
            sleep 1;
          done
        env:
        - name: POSTGRES_PORT
          value: "5432"
        - name: POSTGRES_HOST
          value: "ccs-postgresql-cluster"
        - name: POSTGRES_USER
          valueFrom:
            secretKeyRef:
              name: "keycloak.keycloak-postgresql-cluster.credentials.postgresql.acid.zalan.do"
              key: username
      containers:
      - name: keycloak
        image: docker.io/coredgeio/keycloak:24.0.5
        imagePullPolicy: Always
        args: ["start"] 
        env:
        - name: KC_DB
          value: "postgres"
        - name: KC_DB_URL
          value: "jdbc:postgresql://ccs-postgresql-cluster:5432/keycloak"
        - name: POSTGRES_DB
          value: "keycloak"
        - name: KC_DB_USERNAME
          valueFrom:
            secretKeyRef:
              name: "keycloak.keycloak-postgresql-cluster.credentials.postgresql.acid.zalan.do"
              key: username
        - name: KC_DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: "keycloak.keycloak-postgresql-cluster.credentials.postgresql.acid.zalan.do"
              key: password
        - name: KEYCLOAK_ADMIN
          valueFrom:
            secretKeyRef:
              name: keycloak-creds
              key: username
        - name: KEYCLOAK_ADMIN_PASSWORD
          valueFrom:
            secretKeyRef:
              name: keycloak-creds
              key: password
        - name: JGROUPS_DISCOVERY_PROTOCOL
          value: "dns.DNS_PING"
        - name: jgroups.dns.query
          value: "keycloak-headless.ccs.svc.cluster.local"
        - name: JAVA_OPTS_APPEND
          value: "-Djgroups.dns.query=keycloak-headless.ccs.svc.cluster.local"
        - name: KC_HTTP_RELATIVE_PATH
          value: "/auth/"
        - name: KC_CACHE
          value: "ispn"
        - name: KC_CACHE_STACK
          value: "kubernetes"
        - name: CACHE_OWNERS_COUNT
          value: "3"
        - name: CACHE_OWNERS_AUTH_SESSIONS_COUNT
          value: "3"
        - name: PROXY_ADDRESS_FORWARDING
          value: "true"
        - name: KC_PROXY
          value: "edge"
        - name: KC_HEALTH_ENABLED
          value: "true"
        - name: KC_METRICS_ENABLED
          value: "true"
        - name: KC_HOSTNAME_STRICT
          value: "false"
        - name: KC_HOSTNAME_STRICT_BACKCHANNEL
          value: "false"
        - name: KC_HOSTNAME_STRICT_HTTPS
          value: "false"
        # - name: KC_HOSTNAME
        #   value: ""
        - name: KC_HTTP_ENABLED
          value: "true"
        - name: KC_LOG_LEVEL
          value: "INFO"
        - name: KC_LOG_CONSOLE_OUTPUT
          value: "default"
        - name: KC_PRODUCTION
          value: "true"
        - name: KC_HTTPS_CERTIFICATE_FILE
          value: /opt/keycloak/certs/tls.crt
        - name: KC_HTTPS_CERTIFICATE_KEY_FILE
          value: /opt/keycloak/certs/tls.key
        resources:
          {}
        ports:
        - name: http
          containerPort: 8080
          protocol: TCP
        - name: https
          containerPort: 8443
          protocol: TCP
        - name: discovery
          containerPort: 7800
          protocol: TCP
        livenessProbe:
          failureThreshold: 3
          initialDelaySeconds: 300
          periodSeconds: 1
          successThreshold: 1
          tcpSocket:
            port: http
          timeoutSeconds: 5
        readinessProbe:
          failureThreshold: 3
          httpGet:
            path: /auth//realms/master
            port: http
            scheme: HTTP
          initialDelaySeconds: 30
          periodSeconds: 10
          successThreshold: 1
          timeoutSeconds: 1
        volumeMounts:
          - name: empty-dir
            mountPath: /tmp
            subPath: tmp-dir
          - mountPath: "/opt/keycloak/certs/"
            name: certificates
            readOnly: true
      volumes:
        - name: empty-dir
          emptyDir: {}
        - name: certificates
          secret:
            secretName: keycloak-tls
            defaultMode: 420
---
# Source: ccs/templates/statefulset.yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: configdb
  namespace: ccs
  annotations:
spec:
  serviceName: "configdb"
  selector:
    matchLabels:
      app: configdb
  replicas: 1
  template:
    metadata:
      labels:
        app: configdb
    spec:
      securityContext:
        fsGroup: 999
        runAsUser: 999
      containers:
      - name: mongodb
        image: coredgeio/mongo:5.0.3
        imagePullPolicy: IfNotPresent
        command: ["bash"]
        args: ["-c", "/start-mongodb.sh"]
        volumeMounts:
        - name: mongodb-data
          mountPath: /data/db
        - name: mongo-script-vol
          mountPath: /start-mongodb.sh
          subPath: start-mongodb.sh
        - name: config-replica-auth-vol
          mountPath: /opt/auth
          subPath: auth
        env:
        - name: MONGO_INITDB_ROOT_USERNAME
          valueFrom:
            secretKeyRef:
              name: configdb-secret
              key: username
        - name: MONGO_INITDB_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: configdb-secret
              key: password
        - name: MONGODB_SERVICE_SERVICE_HOST
          value: "configdb"
        - name: REPLICA_COUNT
          value: "1"
        ports:
        - name: mongodb
          containerPort: 27017
#        livenessProbe:
#          exec:
#            command:
#            - mongosh
#            - -u
#            - $MONGO_INITDB_ROOT_USERNAME
#            - -p
#            - $MONGO_INITDB_ROOT_PASSWORD
#            - --eval
#            - db.adminCommand("ping")
#          failureThreshold: 3
#          periodSeconds: 10
#          #successThreshold: 2
#          timeoutSeconds: 2
#          initialDelaySeconds: 10
        readinessProbe:
          exec:
            command:
            - /usr/bin/echo
            - "hello"
#            - mongosh
#            - -u
#            - $MONGO_INITDB_ROOT_USERNAME
#            - -p
#            - $MONGO_INITDB_ROOT_PASSWORD
#            - --eval
#            - db.adminCommand("ping")
#          failureThreshold: 10
#          periodSeconds: 5
#          #successThreshold: 2
#          timeoutSeconds: 2
          initialDelaySeconds: 10
      imagePullSecrets:
      - name: ccs-docker-registry-key
      volumes:
      - name: config-replica-auth-vol
        secret:
          secretName: config-replica-auth
          defaultMode: 0400
      - name: mongo-script-vol
        configMap:
          name: mongo-init
          defaultMode: 0555
  volumeClaimTemplates:
  - metadata:
      name: mongodb-data
    spec:
      accessModes:
      - "ReadWriteOnce"
      resources:
        requests:
          storage: 2Gi
---
# Source: ccs/templates/statefulset.yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: metricsdb
  namespace: ccs
  annotations:
spec:
  serviceName: "metricsdb"
  selector:
    matchLabels:
      app: metricsdb
  replicas: 1
  template:
    metadata:
      labels:
        app: metricsdb
    spec:
      securityContext:
        fsGroup: 999
        runAsUser: 999
      containers:
      - name: mongodb
        image: coredgeio/mongo:5.0.3
        imagePullPolicy: IfNotPresent
        command: ["bash"]
        args: ["-c", "/start-mongodb.sh"]
        volumeMounts:
        - name: mongodb-data
          mountPath: /data/db
        - name: mongo-script-vol
          mountPath: /start-mongodb.sh
          subPath: start-mongodb.sh
        - name: config-replica-auth-vol
          mountPath: /opt/auth
          subPath: auth
        env:
        - name: MONGO_INITDB_ROOT_USERNAME
          valueFrom:
            secretKeyRef:
              name: configdb-secret
              key: username
        - name: MONGO_INITDB_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: configdb-secret
              key: password
        - name: MONGODB_SERVICE_SERVICE_HOST
          value: "metricsdb"
        - name: REPLICA_COUNT
          value: "1"
        ports:
        - name: mongodb
          containerPort: 27017
        readinessProbe:
          exec:
            command:
            - /usr/bin/echo
            - "hello"
          initialDelaySeconds: 10
      imagePullSecrets:
      - name: ccs-docker-registry-key
      volumes:
      - name: config-replica-auth-vol
        secret:
          secretName: config-replica-auth
          defaultMode: 0400
      - name: mongo-script-vol
        configMap:
          name: mongo-init
          defaultMode: 0555
  volumeClaimTemplates:
  - metadata:
      name: mongodb-data
    spec:
      accessModes:
      - "ReadWriteOnce"
      resources:
        requests:
          storage: 2Gi
---
# Source: ccs/templates/statefulset.yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: notification-store
  namespace: ccs
spec:
  serviceName: "notification-store"
  selector:
    matchLabels:
      app: notification-store
  replicas: 1
  template:
    metadata:
      labels:
        app: notification-store
    spec:
      containers:
      - name: redis
        image: coredgeio/redis:6.2.5
        imagePullPolicy: IfNotPresent
        ports:
        - name: redisport
          containerPort: 6380
        volumeMounts:
          - name: redis-data
            mountPath: /data
  volumeClaimTemplates:
  - metadata:
      name: redis-data
    spec:
      accessModes:
      - "ReadWriteOnce"
      resources:
        requests:
          storage: 2Gi
---
# Source: ccs/templates/statefulset.yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: cache-store
  namespace: ccs
  labels:
    app: cache-store
spec:
  serviceName: "cache-store"
  replicas: 1
  selector:
    matchLabels:
      app: cache-store
  template:
    metadata:
      labels:
        app: cache-store
    spec:
      dnsPolicy: ClusterFirst
      containers:
      - name: redis
        image: coredgeio/redis:6.2.5
        imagePullPolicy: Always
        ports:
        - containerPort: 6379
          protocol: TCP
        env:
          - name: ALLOW_EMPTY_PASSWORD
            value: "yes"
        volumeMounts:
          - name: cache-store-data
            mountPath: /data
  volumeClaimTemplates:
    - metadata:
        name: cache-store-data
      spec:
        accessModes:
        - "ReadWriteOnce"
        resources:
          requests:
            storage: 5Gi
---
# Source: ccs/templates/job.yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: compass-init-20250325053608
  namespace: ccs
spec:
  template:
    spec:
      serviceAccountName: compass-controller
      containers:
      - name: setup
        image: coredgeio/compass-init:latest
        imagePullPolicy: IfNotPresent
      restartPolicy: OnFailure
      imagePullSecrets:
      - name: ccs-docker-registry-key
---
# Source: ccs/charts/keycloak-ha/templates/postgresql-rbac.yaml
## Necessary rbac required to manage checks for keycloak postgresql HA custom resource
---
# Source: ccs/charts/userPortal/templates/ingress.yaml
#
---
# Source: ccs/templates/postgresql-ha/rbac.yaml
## Necessary rbac required to manage checks for ccp postgresql HA custom resource
---
# Source: ccs/charts/postgres-operator/templates/operatorconfiguration.yaml
apiVersion: "acid.zalan.do/v1"
kind: OperatorConfiguration
metadata:
  name: ccs-postgres-operator
  namespace: ccs
  labels:
    app.kubernetes.io/name: postgres-operator
    helm.sh/chart: postgres-operator-1.12.2
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/instance: ccs
configuration:
  crd_categories:
  - all
  docker_image: ghcr.io/zalando/spilo-16:3.2-p3
  enable_crd_registration: true
  enable_lazy_spilo_upgrade: false
  enable_pgversion_env_var: true
  enable_shm_volume: true
  enable_spilo_wal_path_compat: false
  enable_team_id_clustername_prefix: false
  etcd_host: ""
  max_instances: -1
  min_instances: -1
  repair_period: 5m
  resync_period: 30m
  workers: 8
  users:
    enable_password_rotation: false
    password_rotation_interval: 90
    password_rotation_user_retention: 180
    replication_username: standby
    super_username: postgres
  major_version_upgrade:
    major_version_upgrade_mode: "off"
    minimal_major_version: "12"
    target_major_version: "16"
  kubernetes:
    pod_service_account_name: postgres-pod
    oauth_token_secret_name: ccs-postgres-operator
    cluster_domain: cluster.local
    cluster_labels:
      application: spilo
    cluster_name_label: cluster-name
    enable_cross_namespace_secret: false
    enable_finalizers: false
    enable_init_containers: true
    enable_persistent_volume_claim_deletion: true
    enable_pod_antiaffinity: false
    enable_pod_disruption_budget: true
    enable_readiness_probe: false
    enable_secrets_deletion: true
    enable_sidecars: true
    pdb_master_label_selector: true
    pdb_name_format: postgres-{cluster}-pdb
    persistent_volume_claim_retention_policy:
      when_deleted: retain
      when_scaled: retain
    pod_antiaffinity_preferred_during_scheduling: false
    pod_antiaffinity_topology_key: kubernetes.io/hostname
    pod_management_policy: ordered_ready
    pod_role_label: spilo-role
    pod_terminate_grace_period: 5m
    secret_name_template: '{username}.{cluster}.credentials.{tprkind}.{tprgroup}'
    share_pgsocket_with_sidecars: false
    spilo_allow_privilege_escalation: true
    spilo_privileged: false
    storage_resize_mode: pvc
    watched_namespace: '*'
  postgres_pod_resources:
    default_cpu_limit: "1"
    default_cpu_request: 100m
    default_memory_limit: 500Mi
    default_memory_request: 100Mi
    min_cpu_limit: 250m
    min_memory_limit: 250Mi
  timeouts:
    patroni_api_check_interval: 1s
    patroni_api_check_timeout: 5s
    pod_deletion_wait_timeout: 10m
    pod_label_wait_timeout: 10m
    ready_wait_interval: 3s
    ready_wait_timeout: 30s
    resource_check_interval: 3s
    resource_check_timeout: 10m
  load_balancer:
    db_hosted_zone: db.example.com
    enable_master_load_balancer: false
    enable_master_pooler_load_balancer: false
    enable_replica_load_balancer: false
    enable_replica_pooler_load_balancer: false
    external_traffic_policy: Cluster
    master_dns_name_format: '{cluster}.{namespace}.{hostedzone}'
    master_legacy_dns_name_format: '{cluster}.{team}.{hostedzone}'
    replica_dns_name_format: '{cluster}-repl.{namespace}.{hostedzone}'
    replica_legacy_dns_name_format: '{cluster}-repl.{team}.{hostedzone}'
  aws_or_gcp:
    aws_region: eu-central-1
    enable_ebs_gp3_migration: false
  logical_backup:
    logical_backup_cronjob_environment_secret: ""
    logical_backup_docker_image: docker.io/coredgeio/postgres-operator-logical-backup:v1.12.2
    logical_backup_job_prefix: logical-backup-
    logical_backup_provider: s3
    logical_backup_s3_access_key_id: ""
    logical_backup_s3_bucket: my-bucket-url
    logical_backup_s3_bucket_prefix: spilo
    logical_backup_s3_endpoint: ""
    logical_backup_s3_region: ""
    logical_backup_s3_retention_time: ""
    logical_backup_s3_secret_access_key: ""
    logical_backup_s3_sse: AES256
    logical_backup_schedule: 30 00 * * *
  debug:
    debug_logging: true
    enable_database_access: true
  teams_api:
    enable_admin_role_for_users: true
    enable_postgres_team_crd: false
    enable_postgres_team_crd_superusers: false
    enable_team_member_deprecation: false
    enable_team_superuser: false
    enable_teams_api: false
    pam_role_name: zalandos
    postgres_superuser_teams:
    - postgres_superusers
    protected_role_names:
    - admin
    - cron_admin
    role_deletion_suffix: _deleted
    team_admin_role: admin
    team_api_role_configuration:
      log_statement: all
  logging_rest_api:
    api_port: 8080
    cluster_history_entries: 1000
    ring_log_lines: 100
  connection_pooler:
    connection_pooler_default_cpu_limit: "1"
    connection_pooler_default_cpu_request: 500m
    connection_pooler_default_memory_limit: 100Mi
    connection_pooler_default_memory_request: 100Mi
    connection_pooler_image: docker.io/coredgeio/pgbouncer:master-32
    connection_pooler_max_db_connections: 500
    connection_pooler_mode: transaction
    connection_pooler_number_of_instances: 2
    connection_pooler_schema: pooler
    connection_pooler_user: pooler
  patroni:
    enable_patroni_failsafe_mode: false
---
# Source: ccs/charts/keycloak-ha/templates/postgresql-cluster.yaml
apiVersion: "acid.zalan.do/v1"
kind: postgresql
metadata:
  name: keycloak-postgresql-cluster
  namespace: ccs
  labels:
    application: keycloak
#    environment: demo
spec: 
  dockerImage: docker.io/coredgeio/spilo-16:3.2-p3
  teamId: "keycloak"
  numberOfInstances: 3
  users:  # Application/Robot users
    zalando:
    - superuser
    - createdb
    keycloak: []
  databases:
    keycloak: keycloak
#  usersWithSecretRotation:
#  - foo_user
#  usersWithInPlaceSecretRotation:
#  - flyway
#  - bar_owner_user
  enableMasterLoadBalancer: false
  enableReplicaLoadBalancer: false
  enableConnectionPooler: false # enable/disable connection pooler deployment
  enableReplicaConnectionPooler: false # set to enable connectionPooler for replica service
  enableMasterPoolerLoadBalancer: false
  enableReplicaPoolerLoadBalancer: false
  allowedSourceRanges:  # load balancers' source ranges for both master and replica services
  - 127.0.0.1/32
  preparedDatabases: {}
  postgresql:
    version: "15"
    parameters:  # Expert section
      shared_buffers: "32MB"
      max_connections: "300"
      log_statement: "all"
  volume:
    size: 10Gi
    storageClass: 
#    selector:
#      matchExpressions:
#        - { key: flavour, operator: In, values: [ "banana", "chocolate" ] }
#      matchLabels:
#        environment: dev
#        service: postgres
  
  additionalVolumes:
    # - name: data
    #   mountPath: /home/postgres/pgdata/partitions
    #   targetContainers:
    #     - postgres
    #   volumeSource:
    #     PersistentVolumeClaim:
    #       claimName: pvc-postgresql-data-partitions
    #       readyOnly: false    
  resources:
    limits:
      cpu: 500m
      memory: 500Mi
    requests:
      cpu: 10m
      memory: 100Mi
  patroni:
    failsafe_mode: false
    initdb:
      encoding: "UTF8"
      locale: "en_US.UTF-8"
      data-checksums: "true"
    pg_hba:
      - local   all             all                                   trust
      - hostssl all             +zalandos    127.0.0.1/32       pam
      - host    all             all                127.0.0.1/32       md5
      - hostssl all             +zalandos    ::1/128            pam
      - host    all             all                ::1/128            md5
      - local   replication     standby                    trust
      - hostssl replication     standby      all                      md5
      - hostssl all             +zalandos    all                pam
      - hostssl all             all                all                md5

# overwrite custom properties for connection pooler deployments
  connectionPooler:
    numberOfInstances: 1
    mode: "transaction"
    schema: "pooler"
    user: "pooler"
    resources:
      requests:
        cpu: 100m
        memory: 250Mi
      limits:
        cpu: "500m"
        memory: 500Mi

  initContainers:
  - name: date
    image: coredgeio/busybox
    command: [ "/bin/date" ]
---
# Source: ccs/templates/postgresql-ha/cluster.yaml
apiVersion: "acid.zalan.do/v1"
kind: postgresql
metadata:
  name: ccs-postgresql-cluster
  namespace: ccs
  labels:
    application: ccs
#    environment: demo
spec: 
  dockerImage: docker.io/coredgeio/spilo-16:3.2-p3
  teamId: ccs
  numberOfInstances: 3
  users:  # Application/Robot users
    zalando:
    - superuser
    - createdb
    ccs: 
    - createdb
  databases: {}
#  usersWithSecretRotation:
#  - foo_user
#  usersWithInPlaceSecretRotation:
#  - flyway
#  - bar_owner_user
  enableMasterLoadBalancer: false
  enableReplicaLoadBalancer: false
  enableConnectionPooler: false # enable/disable connection pooler deployment
  enableReplicaConnectionPooler: false # set to enable connectionPooler for replica service
  enableMasterPoolerLoadBalancer: false
  enableReplicaPoolerLoadBalancer: false
  allowedSourceRanges:  # load balancers' source ranges for both master and replica services
  - 127.0.0.1/32
  preparedDatabases: {}
  postgresql:
    version: "15"
    parameters:  # Expert section
      shared_buffers: "32MB"
      max_connections: "300"
      log_statement: "all"
  
  volume:
    size: 10Gi
    storageClass: 
#    selector:
#      matchExpressions:
#        - { key: flavour, operator: In, values: [ "banana", "chocolate" ] }
#      matchLabels:
#        environment: dev
#        service: postgres
  
  additionalVolumes:
    # - name: data
    #   mountPath: /home/postgres/pgdata/partitions
    #   targetContainers:
    #     - postgres
    #   volumeSource:
    #     PersistentVolumeClaim:
    #       claimName: pvc-postgresql-data-partitions
    #       readyOnly: false    

  resources:
    limits:
      cpu: 500m
      memory: 500Mi
    requests:
      cpu: 10m
      memory: 100Mi
  patroni:
    failsafe_mode: false
    initdb:
      encoding: "UTF8"
      locale: "en_US.UTF-8"
      data-checksums: "true"
    pg_hba:
      - local   all             all                                   trust
      - hostssl all             +zalandos    127.0.0.1/32       pam
      - host    all             all                127.0.0.1/32       md5
      - hostssl all             +zalandos    ::1/128            pam
      - host    all             all                ::1/128            md5
      - local   replication     standby                    trust
      - hostssl replication     standby      all                      md5
      - hostssl all             +zalandos    all                pam
      - hostssl all             all                all                md5
# overwrite custom properties for connection pooler deployments
  connectionPooler:
    numberOfInstances: 1
    mode: "transaction"
    schema: "pooler"
    user: "pooler"
    resources:
      requests:
        cpu: 100m
        memory: 250Mi
      limits:
        cpu: "500m"
        memory: 500Mi

  initContainers:
  - name: date
    image: coredgeio/busybox
    command: [ "/bin/date" ]

