// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package workflow

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// ModuleApiClient is the client API for ModuleApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ModuleApiClient interface {
	// List Modules in a project
	ListModules(ctx context.Context, in *ModulesListReq, opts ...grpc.CallOption) (*ModulesListResp, error)
	// Create a new Module
	CreateModule(ctx context.Context, in *ModuleCreateReq, opts ...grpc.CallOption) (*ModuleCreateResp, error)
	// Get module
	GetModule(ctx context.Context, in *ModuleEntryKey, opts ...grpc.CallOption) (*ModuleGetResp, error)
	// Update module
	UpdateModule(ctx context.Context, in *ModuleCreateReq, opts ...grpc.CallOption) (*ModuleCreateResp, error)
	// Delete module
	DeleteModule(ctx context.Context, in *ModuleEntryKey, opts ...grpc.CallOption) (*ModuleDeleteResp, error)
	// trigger rebuild of the module image
	RebuildModule(ctx context.Context, in *ModuleEntryKey, opts ...grpc.CallOption) (*ModuleRebuildResp, error)
	// create a catalog request from module
	CreateCatalogRequest(ctx context.Context, in *ModuleCatalogCreateReq, opts ...grpc.CallOption) (*ModuleCatalogCreateResp, error)
	// delete catalog request from module
	DeleteCatalogRequest(ctx context.Context, in *ModuleCatalogDeleteReq, opts ...grpc.CallOption) (*ModuleCatalogDeleteResp, error)
	// provide option for project members to add comments to the module audit trail,
	// available only if request for the module is created
	AddModuleComment(ctx context.Context, in *ModuleCommentAddReq, opts ...grpc.CallOption) (*ModuleCommentAddResp, error)
	// list catalog of modules (approved)
	ListModuleCatalog(ctx context.Context, in *ModuleCatalogListReq, opts ...grpc.CallOption) (*ModuleCatalogListResp, error)
	// list catalog versions of modules (approved)
	ListModuleCatalogVer(ctx context.Context, in *ModuleCatalogVerListReq, opts ...grpc.CallOption) (*ModuleCatalogVerListResp, error)
	// list of module catalog review request
	ListModuleCatalogRequest(ctx context.Context, in *ModuleCatalogRequestListReq, opts ...grpc.CallOption) (*ModuleCatalogRequestListResp, error)
}

type moduleApiClient struct {
	cc grpc.ClientConnInterface
}

func NewModuleApiClient(cc grpc.ClientConnInterface) ModuleApiClient {
	return &moduleApiClient{cc}
}

func (c *moduleApiClient) ListModules(ctx context.Context, in *ModulesListReq, opts ...grpc.CallOption) (*ModulesListResp, error) {
	out := new(ModulesListResp)
	err := c.cc.Invoke(ctx, "/workflow.ModuleApi/ListModules", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *moduleApiClient) CreateModule(ctx context.Context, in *ModuleCreateReq, opts ...grpc.CallOption) (*ModuleCreateResp, error) {
	out := new(ModuleCreateResp)
	err := c.cc.Invoke(ctx, "/workflow.ModuleApi/CreateModule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *moduleApiClient) GetModule(ctx context.Context, in *ModuleEntryKey, opts ...grpc.CallOption) (*ModuleGetResp, error) {
	out := new(ModuleGetResp)
	err := c.cc.Invoke(ctx, "/workflow.ModuleApi/GetModule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *moduleApiClient) UpdateModule(ctx context.Context, in *ModuleCreateReq, opts ...grpc.CallOption) (*ModuleCreateResp, error) {
	out := new(ModuleCreateResp)
	err := c.cc.Invoke(ctx, "/workflow.ModuleApi/UpdateModule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *moduleApiClient) DeleteModule(ctx context.Context, in *ModuleEntryKey, opts ...grpc.CallOption) (*ModuleDeleteResp, error) {
	out := new(ModuleDeleteResp)
	err := c.cc.Invoke(ctx, "/workflow.ModuleApi/DeleteModule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *moduleApiClient) RebuildModule(ctx context.Context, in *ModuleEntryKey, opts ...grpc.CallOption) (*ModuleRebuildResp, error) {
	out := new(ModuleRebuildResp)
	err := c.cc.Invoke(ctx, "/workflow.ModuleApi/RebuildModule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *moduleApiClient) CreateCatalogRequest(ctx context.Context, in *ModuleCatalogCreateReq, opts ...grpc.CallOption) (*ModuleCatalogCreateResp, error) {
	out := new(ModuleCatalogCreateResp)
	err := c.cc.Invoke(ctx, "/workflow.ModuleApi/CreateCatalogRequest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *moduleApiClient) DeleteCatalogRequest(ctx context.Context, in *ModuleCatalogDeleteReq, opts ...grpc.CallOption) (*ModuleCatalogDeleteResp, error) {
	out := new(ModuleCatalogDeleteResp)
	err := c.cc.Invoke(ctx, "/workflow.ModuleApi/DeleteCatalogRequest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *moduleApiClient) AddModuleComment(ctx context.Context, in *ModuleCommentAddReq, opts ...grpc.CallOption) (*ModuleCommentAddResp, error) {
	out := new(ModuleCommentAddResp)
	err := c.cc.Invoke(ctx, "/workflow.ModuleApi/AddModuleComment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *moduleApiClient) ListModuleCatalog(ctx context.Context, in *ModuleCatalogListReq, opts ...grpc.CallOption) (*ModuleCatalogListResp, error) {
	out := new(ModuleCatalogListResp)
	err := c.cc.Invoke(ctx, "/workflow.ModuleApi/ListModuleCatalog", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *moduleApiClient) ListModuleCatalogVer(ctx context.Context, in *ModuleCatalogVerListReq, opts ...grpc.CallOption) (*ModuleCatalogVerListResp, error) {
	out := new(ModuleCatalogVerListResp)
	err := c.cc.Invoke(ctx, "/workflow.ModuleApi/ListModuleCatalogVer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *moduleApiClient) ListModuleCatalogRequest(ctx context.Context, in *ModuleCatalogRequestListReq, opts ...grpc.CallOption) (*ModuleCatalogRequestListResp, error) {
	out := new(ModuleCatalogRequestListResp)
	err := c.cc.Invoke(ctx, "/workflow.ModuleApi/ListModuleCatalogRequest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ModuleApiServer is the server API for ModuleApi service.
// All implementations must embed UnimplementedModuleApiServer
// for forward compatibility
type ModuleApiServer interface {
	// List Modules in a project
	ListModules(context.Context, *ModulesListReq) (*ModulesListResp, error)
	// Create a new Module
	CreateModule(context.Context, *ModuleCreateReq) (*ModuleCreateResp, error)
	// Get module
	GetModule(context.Context, *ModuleEntryKey) (*ModuleGetResp, error)
	// Update module
	UpdateModule(context.Context, *ModuleCreateReq) (*ModuleCreateResp, error)
	// Delete module
	DeleteModule(context.Context, *ModuleEntryKey) (*ModuleDeleteResp, error)
	// trigger rebuild of the module image
	RebuildModule(context.Context, *ModuleEntryKey) (*ModuleRebuildResp, error)
	// create a catalog request from module
	CreateCatalogRequest(context.Context, *ModuleCatalogCreateReq) (*ModuleCatalogCreateResp, error)
	// delete catalog request from module
	DeleteCatalogRequest(context.Context, *ModuleCatalogDeleteReq) (*ModuleCatalogDeleteResp, error)
	// provide option for project members to add comments to the module audit trail,
	// available only if request for the module is created
	AddModuleComment(context.Context, *ModuleCommentAddReq) (*ModuleCommentAddResp, error)
	// list catalog of modules (approved)
	ListModuleCatalog(context.Context, *ModuleCatalogListReq) (*ModuleCatalogListResp, error)
	// list catalog versions of modules (approved)
	ListModuleCatalogVer(context.Context, *ModuleCatalogVerListReq) (*ModuleCatalogVerListResp, error)
	// list of module catalog review request
	ListModuleCatalogRequest(context.Context, *ModuleCatalogRequestListReq) (*ModuleCatalogRequestListResp, error)
	mustEmbedUnimplementedModuleApiServer()
}

// UnimplementedModuleApiServer must be embedded to have forward compatible implementations.
type UnimplementedModuleApiServer struct {
}

func (UnimplementedModuleApiServer) ListModules(context.Context, *ModulesListReq) (*ModulesListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListModules not implemented")
}
func (UnimplementedModuleApiServer) CreateModule(context.Context, *ModuleCreateReq) (*ModuleCreateResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateModule not implemented")
}
func (UnimplementedModuleApiServer) GetModule(context.Context, *ModuleEntryKey) (*ModuleGetResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetModule not implemented")
}
func (UnimplementedModuleApiServer) UpdateModule(context.Context, *ModuleCreateReq) (*ModuleCreateResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateModule not implemented")
}
func (UnimplementedModuleApiServer) DeleteModule(context.Context, *ModuleEntryKey) (*ModuleDeleteResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteModule not implemented")
}
func (UnimplementedModuleApiServer) RebuildModule(context.Context, *ModuleEntryKey) (*ModuleRebuildResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RebuildModule not implemented")
}
func (UnimplementedModuleApiServer) CreateCatalogRequest(context.Context, *ModuleCatalogCreateReq) (*ModuleCatalogCreateResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCatalogRequest not implemented")
}
func (UnimplementedModuleApiServer) DeleteCatalogRequest(context.Context, *ModuleCatalogDeleteReq) (*ModuleCatalogDeleteResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCatalogRequest not implemented")
}
func (UnimplementedModuleApiServer) AddModuleComment(context.Context, *ModuleCommentAddReq) (*ModuleCommentAddResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddModuleComment not implemented")
}
func (UnimplementedModuleApiServer) ListModuleCatalog(context.Context, *ModuleCatalogListReq) (*ModuleCatalogListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListModuleCatalog not implemented")
}
func (UnimplementedModuleApiServer) ListModuleCatalogVer(context.Context, *ModuleCatalogVerListReq) (*ModuleCatalogVerListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListModuleCatalogVer not implemented")
}
func (UnimplementedModuleApiServer) ListModuleCatalogRequest(context.Context, *ModuleCatalogRequestListReq) (*ModuleCatalogRequestListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListModuleCatalogRequest not implemented")
}
func (UnimplementedModuleApiServer) mustEmbedUnimplementedModuleApiServer() {}

// UnsafeModuleApiServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ModuleApiServer will
// result in compilation errors.
type UnsafeModuleApiServer interface {
	mustEmbedUnimplementedModuleApiServer()
}

func RegisterModuleApiServer(s grpc.ServiceRegistrar, srv ModuleApiServer) {
	s.RegisterService(&ModuleApi_ServiceDesc, srv)
}

func _ModuleApi_ListModules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModulesListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModuleApiServer).ListModules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/workflow.ModuleApi/ListModules",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModuleApiServer).ListModules(ctx, req.(*ModulesListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModuleApi_CreateModule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModuleCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModuleApiServer).CreateModule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/workflow.ModuleApi/CreateModule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModuleApiServer).CreateModule(ctx, req.(*ModuleCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModuleApi_GetModule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModuleEntryKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModuleApiServer).GetModule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/workflow.ModuleApi/GetModule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModuleApiServer).GetModule(ctx, req.(*ModuleEntryKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModuleApi_UpdateModule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModuleCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModuleApiServer).UpdateModule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/workflow.ModuleApi/UpdateModule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModuleApiServer).UpdateModule(ctx, req.(*ModuleCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModuleApi_DeleteModule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModuleEntryKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModuleApiServer).DeleteModule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/workflow.ModuleApi/DeleteModule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModuleApiServer).DeleteModule(ctx, req.(*ModuleEntryKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModuleApi_RebuildModule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModuleEntryKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModuleApiServer).RebuildModule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/workflow.ModuleApi/RebuildModule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModuleApiServer).RebuildModule(ctx, req.(*ModuleEntryKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModuleApi_CreateCatalogRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModuleCatalogCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModuleApiServer).CreateCatalogRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/workflow.ModuleApi/CreateCatalogRequest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModuleApiServer).CreateCatalogRequest(ctx, req.(*ModuleCatalogCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModuleApi_DeleteCatalogRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModuleCatalogDeleteReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModuleApiServer).DeleteCatalogRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/workflow.ModuleApi/DeleteCatalogRequest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModuleApiServer).DeleteCatalogRequest(ctx, req.(*ModuleCatalogDeleteReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModuleApi_AddModuleComment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModuleCommentAddReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModuleApiServer).AddModuleComment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/workflow.ModuleApi/AddModuleComment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModuleApiServer).AddModuleComment(ctx, req.(*ModuleCommentAddReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModuleApi_ListModuleCatalog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModuleCatalogListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModuleApiServer).ListModuleCatalog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/workflow.ModuleApi/ListModuleCatalog",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModuleApiServer).ListModuleCatalog(ctx, req.(*ModuleCatalogListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModuleApi_ListModuleCatalogVer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModuleCatalogVerListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModuleApiServer).ListModuleCatalogVer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/workflow.ModuleApi/ListModuleCatalogVer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModuleApiServer).ListModuleCatalogVer(ctx, req.(*ModuleCatalogVerListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModuleApi_ListModuleCatalogRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModuleCatalogRequestListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModuleApiServer).ListModuleCatalogRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/workflow.ModuleApi/ListModuleCatalogRequest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModuleApiServer).ListModuleCatalogRequest(ctx, req.(*ModuleCatalogRequestListReq))
	}
	return interceptor(ctx, in, info, handler)
}

// ModuleApi_ServiceDesc is the grpc.ServiceDesc for ModuleApi service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ModuleApi_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "workflow.ModuleApi",
	HandlerType: (*ModuleApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListModules",
			Handler:    _ModuleApi_ListModules_Handler,
		},
		{
			MethodName: "CreateModule",
			Handler:    _ModuleApi_CreateModule_Handler,
		},
		{
			MethodName: "GetModule",
			Handler:    _ModuleApi_GetModule_Handler,
		},
		{
			MethodName: "UpdateModule",
			Handler:    _ModuleApi_UpdateModule_Handler,
		},
		{
			MethodName: "DeleteModule",
			Handler:    _ModuleApi_DeleteModule_Handler,
		},
		{
			MethodName: "RebuildModule",
			Handler:    _ModuleApi_RebuildModule_Handler,
		},
		{
			MethodName: "CreateCatalogRequest",
			Handler:    _ModuleApi_CreateCatalogRequest_Handler,
		},
		{
			MethodName: "DeleteCatalogRequest",
			Handler:    _ModuleApi_DeleteCatalogRequest_Handler,
		},
		{
			MethodName: "AddModuleComment",
			Handler:    _ModuleApi_AddModuleComment_Handler,
		},
		{
			MethodName: "ListModuleCatalog",
			Handler:    _ModuleApi_ListModuleCatalog_Handler,
		},
		{
			MethodName: "ListModuleCatalogVer",
			Handler:    _ModuleApi_ListModuleCatalogVer_Handler,
		},
		{
			MethodName: "ListModuleCatalogRequest",
			Handler:    _ModuleApi_ListModuleCatalogRequest_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "module.proto",
}
